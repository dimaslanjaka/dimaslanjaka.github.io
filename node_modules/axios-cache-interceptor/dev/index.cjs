(()=>{"use strict";var e={d:(t,a)=>{for(var r in a)e.o(a,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:a[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{Header:()=>r,buildKeyGenerator:()=>S,buildMemoryStorage:()=>w,buildStorage:()=>b,buildWebStorage:()=>E,canStale:()=>m,createCacheResponse:()=>c,createValidateStatus:()=>n,defaultHeaderInterpreter:()=>i,defaultKeyGenerator:()=>I,defaultRequestInterceptor:()=>l,defaultResponseInterceptor:()=>g,isExpired:()=>v,isMethodIn:()=>d,isStorage:()=>f,setupCache:()=>x,testCachePredicate:()=>u,updateCache:()=>h,updateStaleRequest:()=>s});const a=require("cache-parser"),r=Object.freeze({IfModifiedSince:"if-modified-since",LastModified:"last-modified",IfNoneMatch:"if-none-match",CacheControl:"cache-control",Pragma:"pragma",ETag:"etag",Expires:"expires",Age:"age",XAxiosCacheEtag:"x-axios-cache-etag",XAxiosCacheLastModified:"x-axios-cache-last-modified",XAxiosCacheStaleIfError:"x-axios-cache-stale-if-error"}),i=e=>{if(!e)return"not enough headers";const t=e[r.CacheControl];if(t){const{noCache:i,noStore:o,maxAge:n,maxStale:d,immutable:s,staleWhileRevalidate:c}=(0,a.parse)(String(t));if(i||o)return"dont cache";if(s)return{cache:31536e6};if(void 0!==n){const t=e[r.Age];return{cache:t?1e3*(n-Number(t)):1e3*n,stale:void 0!==d?1e3*d:void 0!==c?1e3*c:void 0}}}const i=e[r.Expires];if(i){const e=Date.parse(String(i))-Date.now();return e>=0?{cache:e}:"dont cache"}return"not enough headers"},o=require("fast-defer");function n(e){return e?t=>e(t)||304===t:e=>e>=200&&e<300||304===e}function d(e="get",t=[]){return e=e.toLowerCase(),t.some((t=>t===e))}function s(e,t){var a;t.headers||(t.headers={});const{etag:i,modifiedSince:o}=t.cache;if(i){const o=!0===i?null===(a=e.data)||void 0===a?void 0:a.headers[r.ETag]:i;o&&(t.headers[r.IfNoneMatch]=o)}o&&(t.headers[r.IfModifiedSince]=!0===o?e.data.headers[r.LastModified]||new Date(e.createdAt).toUTCString():o.toUTCString())}function c(e,t){return 304===e.status&&t?(e.cached=!0,e.data=t.data,e.status=t.status,e.statusText=t.statusText,e.headers=Object.assign(Object.assign({},t.headers),e.headers),t):{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers}}function l(e){const t=async a=>{var i,c,l,u,h,g,f,p,m,v,b,w,y,C,S,I,x,E,j,A,O,T,M;if(a.id=e.generateKey(a),!1===a.cache)return null===(i=e.debug)||void 0===i||i.call(e,{msg:"Ignoring cache because config.cache === false",data:a}),a;if(a.cache=Object.assign(Object.assign({},e.defaults.cache),a.cache),a.cache.cacheTakeover&&(null!==(c=(E=a.headers)[j=r.CacheControl])&&void 0!==c||(E[j]="no-cache"),null!==(l=(A=a.headers)[O=r.Pragma])&&void 0!==l||(A[O]="no-cache"),null!==(u=(T=a.headers)[M=r.Expires])&&void 0!==u||(T[M]="0")),!d(a.method,a.cache.methods))return null===(h=e.debug)||void 0===h||h.call(e,{msg:`Ignored because method (${a.method}) is not in cache.methods (${a.cache.methods})`}),a;let R=await e.storage.get(a.id,a);const q=a.cache.override;e:if("empty"===R.state||"stale"===R.state||q){if(e.waiting[a.id]&&!q&&(R=await e.storage.get(a.id,a),"empty"!==R.state)){null===(g=e.debug)||void 0===g||g.call(e,{id:a.id,msg:"Waiting list had an deferred for this key, waiting for it to finish"});break e}return e.waiting[a.id]=(0,o.deferred)(),e.waiting[a.id].catch((()=>{})),await e.storage.set(a.id,{state:"loading",previous:q?R.data?"stale":"empty":R.state,data:R.data,createdAt:q&&!R.createdAt?Date.now():R.createdAt},a),"stale"===R.state&&(s(R,a),null===(f=e.debug)||void 0===f||f.call(e,{id:a.id,msg:"Updated stale request"})),a.validateStatus=n(a.validateStatus),null===(p=e.debug)||void 0===p||p.call(e,{id:a.id,msg:"Sending request, waiting for response",data:{overrideCache:q,state:R.state}}),("stale"===R.state||R.data)&&await(null===(v=(m=a.cache).hydrate)||void 0===v?void 0:v.call(m,R)),a}let k;if("loading"===R.state){const r=e.waiting[a.id];if(!r)return R.data&&await(null===(w=(b=a.cache).hydrate)||void 0===w?void 0:w.call(b,R)),a;null===(y=e.debug)||void 0===y||y.call(e,{id:a.id,msg:"Detected concurrent request, waiting for it to finish"});try{k=await r}catch(r){return null===(C=e.debug)||void 0===C||C.call(e,{id:a.id,msg:"Deferred rejected, requesting again",data:r}),R.data&&await(null===(I=(S=a.cache).hydrate)||void 0===I?void 0:I.call(S,R)),t(a)}}else k=R.data;return a.adapter=function(){return Promise.resolve({config:a,data:k.data,headers:k.headers,status:k.status,statusText:k.statusText,cached:!0,id:a.id})},null===(x=e.debug)||void 0===x||x.call(e,{id:a.id,msg:"Returning cached response"}),a};return{onFulfilled:t,apply:()=>e.interceptors.request.use(t)}}async function u(e,t){var a;if("function"==typeof t)return t(e);const{statusCheck:r,responseMatch:i,containsHeaders:o}=t;if(r&&!await r(e.status)||i&&!await i(e))return!1;if(o)for(const[t,r]of Object.entries(o))if(!await r(null!==(a=e.headers[t.toLowerCase()])&&void 0!==a?a:e.headers[t]))return!1;return!0}async function h(e,t,a){if("function"==typeof a)return a(t);for(const[r,i]of Object.entries(a)){if("delete"===i){await e.remove(r,t.config);continue}const a=await e.get(r,t.config);if("loading"===a.state)continue;const o=await i(a,t);"delete"!==o?"ignore"!==o&&await e.set(r,o,t.config):await e.remove(r,t.config)}}function g(e){const t=async(t,a)=>{var r;await e.storage.remove(t,a),null===(r=e.waiting[t])||void 0===r||r.reject(),delete e.waiting[t]},i=async a=>{var i,o,n,s,l,g,f,p,m,v,b;if(!(null==a?void 0:a.config))throw null===(i=e.debug)||void 0===i||i.call(e,{msg:"Response interceptor received an unknown response.",data:a}),a;a.id=a.config.id,null!==(o=a.cached)&&void 0!==o||(a.cached=!1);const w=a.config,y=w.cache;if(a.cached)return null===(n=e.debug)||void 0===n||n.call(e,{id:a.id,msg:"Returned cached response"}),a;if(!y)return null===(s=e.debug)||void 0===s||s.call(e,{id:a.id,msg:"Response with config.cache falsy",data:a}),a.cached=!1,a;if(y.update&&await h(e.storage,a,y.update),!d(w.method,y.methods))return null===(l=e.debug)||void 0===l||l.call(e,{id:a.id,msg:`Ignored because method (${w.method}) is not in cache.methods (${y.methods})`,data:{config:w,cacheConfig:y}}),a;const C=await e.storage.get(a.id,w);if("loading"!==C.state)return null===(g=e.debug)||void 0===g||g.call(e,{id:a.id,msg:"Response not cached and storage isn't loading",data:{cache:C,response:a}}),a;if(!C.data&&!await u(a,y.cachePredicate))return await t(a.id,w),null===(f=e.debug)||void 0===f||f.call(e,{id:a.id,msg:"Cache predicate rejected this response"}),a;for(const e of Object.keys(a.headers))e.startsWith("x-axios-cache")&&delete a.headers[e];y.etag&&!0!==y.etag&&(a.headers[r.XAxiosCacheEtag]=y.etag),y.modifiedSince&&(a.headers[r.XAxiosCacheLastModified]=!0===y.modifiedSince?"use-cache-timestamp":y.modifiedSince.toUTCString());let S,I=y.ttl||-1;if(y.interpretHeader){const r=e.headerInterpreter(a.headers);if("dont cache"===r)return await t(a.id,w),null===(p=e.debug)||void 0===p||p.call(e,{id:a.id,msg:"Cache header interpreted as 'dont cache'",data:{cache:C,response:a,expirationTime:r}}),a;"not enough headers"!==r&&("number"==typeof r?I=r:(I=r.cache,S=r.stale))}const x=c(a,C.data);"function"==typeof I&&(I=await I(a)),y.staleIfError&&(a.headers[r.XAxiosCacheStaleIfError]=String(I)),null===(m=e.debug)||void 0===m||m.call(e,{id:a.id,msg:"Useful response configuration found",data:{cacheConfig:y,cacheResponse:x}});const E={state:"cached",ttl:I,staleTtl:S,createdAt:Date.now(),data:x},j=e.waiting[a.id];return j&&(j.resolve(E.data),delete e.waiting[a.id],null===(v=e.debug)||void 0===v||v.call(e,{id:a.id,msg:"Found waiting deferred(s) and resolved them"})),await e.storage.set(a.id,E,w),null===(b=e.debug)||void 0===b||b.call(e,{id:a.id,msg:"Response cached",data:{cache:E,response:a}}),a},o=async i=>{var o,n,s,c,l,u,h,g;if(!i.isAxiosError)throw null===(o=e.debug)||void 0===o||o.call(e,{msg:"Received an non axios error in the rejected response interceptor, ignoring.",data:i}),i;const f=i.config,p=f.id,m=f.cache,v=i.response;if(!m||!p)throw null===(n=e.debug)||void 0===n||n.call(e,{msg:"Web request returned an error but cache handling is not enabled",data:{error:i}}),i;if(!d(f.method,m.methods))throw null===(s=e.debug)||void 0===s||s.call(e,{id:p,msg:`Ignored because method (${f.method}) is not in cache.methods (${m.methods})`,data:{config:f,cacheConfig:m}}),i;const b=await e.storage.get(p,f);if("loading"!==b.state||"stale"!==b.previous)throw await t(p,f),null===(c=e.debug)||void 0===c||c.call(e,{id:p,msg:"Caught an error in the request interceptor",data:{cache:b,error:i,config:f}}),i;if(m.staleIfError){const t=String(null==v?void 0:v.headers[r.CacheControl]),o=t&&(0,a.parse)(t).staleIfError,n="function"==typeof m.staleIfError?await m.staleIfError(v,b,i):!0===m.staleIfError&&o?1e3*o:m.staleIfError;if(null===(l=e.debug)||void 0===l||l.call(e,{id:p,msg:"Found cache if stale config for rejected response",data:{error:i,config:f,staleIfError:n}}),!0===n||"number"==typeof n&&b.createdAt+n>Date.now())return null===(u=e.waiting[p])||void 0===u||u.resolve(b.data),delete e.waiting[p],await e.storage.set(p,{state:"stale",createdAt:Date.now(),data:b.data},f),null===(h=e.debug)||void 0===h||h.call(e,{id:p,msg:"staleIfError resolved this response with cached data",data:{error:i,config:f,cache:b}}),{cached:!0,config:f,id:p,data:b.data.data,headers:b.data.headers,status:b.data.status,statusText:b.data.statusText}}throw null===(g=e.debug)||void 0===g||g.call(e,{id:p,msg:"Received an unknown error that could not be handled",data:{error:i,config:f}}),i};return{onFulfilled:i,onRejected:o,apply:()=>e.interceptors.response.use(i,o)}}const f=e=>!!e&&!!e["is-storage"];function p(e){const t=e.data.headers;return r.ETag in t||r.LastModified in t||r.XAxiosCacheEtag in t||r.XAxiosCacheLastModified in t}function m(e){return!String(e.data.headers[r.CacheControl]).includes("must-revalidate")&&(!!p(e)||"cached"===e.state&&void 0!==e.staleTtl&&Math.abs(Date.now()-(e.createdAt+e.ttl))<=e.staleTtl)}function v(e){return void 0!==e.ttl&&e.createdAt+e.ttl<=Date.now()}function b({set:e,find:t,remove:a}){return{"is-storage":1,set:e,remove:a,get:async(r,i)=>{let o=await t(r,i);if(!o)return{state:"empty"};if("empty"===o.state||"loading"===o.state)return o;if("cached"===o.state){if(!v(o))return o;if(!m(o))return await a(r,i),{state:"empty"};o={state:"stale",createdAt:o.createdAt,data:o.data,ttl:void 0!==o.staleTtl?o.staleTtl+o.ttl:void 0},await e(r,o,i)}return v(o)?p(o)?o:(await a(r,i),{state:"empty"}):o}}}function w(e=!1,t=!1,a=!1){const r=b({set:(t,i)=>{if(a){let e=Object.keys(r.data);if(e.length>=a)for(r.cleanup(),e=Object.keys(r.data);e.length>=a;)delete r.data[e.shift()]}r.data[t]="double"===e?"function"==typeof structuredClone?structuredClone(i):JSON.parse(JSON.stringify(i)):i},remove:e=>{delete r.data[e]},find:t=>{const a=r.data[t];return e&&void 0!==a?"function"==typeof structuredClone?structuredClone(a):JSON.parse(JSON.stringify(a)):a}});return r.data=Object.create(null),r.cleanup=()=>{const e=Object.keys(r.data);let t,a,i=-1;for(;++i<e.length;)a=e[i],t=r.data[a],"empty"!==t.state?"cached"===t.state&&v(t)&&!m(t)&&r.remove(a):r.remove(a)},t&&(r.cleaner=setInterval(r.cleanup,t)),r}const y=require("object-code"),C=/^\/|\/$/g;function S(e){return t=>{if(t.id)return t.id;const a=e(t);return"string"==typeof a||"number"==typeof a?`${a}`:`${(0,y.hash)(a)}`}}const I=S((({baseURL:e="",url:t="",method:a="get",params:r,data:i})=>(e&&(e=e.replace(C,"")),t&&(t=t.replace(C,"")),a&&(a=a.toLowerCase()),{url:e+(e&&t?"/":"")+t,params:r,method:a,data:i})));function x(e,t={}){var a,r,o,n,d,s;const c=e;if(c.defaults.cache)throw new Error("setupCache() should be called only once");if(c.storage=t.storage||w(),!f(c.storage))throw new Error("Use buildStorage() function");return c.waiting=t.waiting||{},c.generateKey=t.generateKey||I,c.headerInterpreter=t.headerInterpreter||i,c.requestInterceptor=t.requestInterceptor||l(c),c.responseInterceptor=t.responseInterceptor||g(c),c.debug=t.debug,c.defaults.cache={update:t.update||{},ttl:null!==(a=t.ttl)&&void 0!==a?a:3e5,methods:t.methods||["get","head"],cachePredicate:t.cachePredicate||{statusCheck:e=>[200,203,300,301,302,404,405,410,414,501].includes(e)},etag:null===(r=t.etag)||void 0===r||r,modifiedSince:null!==(o=t.modifiedSince)&&void 0!==o?o:!1===t.etag,interpretHeader:null===(n=t.interpretHeader)||void 0===n||n,cacheTakeover:null===(d=t.cacheTakeover)||void 0===d||d,staleIfError:null===(s=t.staleIfError)||void 0===s||s,override:!1,hydrate:void 0},c.requestInterceptor.apply(),c.responseInterceptor.apply(),c}function E(e,t="axios-cache-"){return b({find:a=>{const r=e.getItem(t+a);return r?JSON.parse(r):void 0},remove:a=>{e.removeItem(t+a)},set:(a,r)=>{const i=()=>e.setItem(t+a,JSON.stringify(r));try{return i()}catch(r){const o=Object.entries(e).filter((e=>e[0].startsWith(t))).map((e=>[e[0],JSON.parse(e[1])]));for(const t of o)"cached"===t[1].state&&v(t[1])&&!m(t[1])&&e.removeItem(t[0]);try{return i()}catch(t){const a=o.sort(((e,t)=>(e[1].createdAt||0)-(t[1].createdAt||0)));for(const t of a){e.removeItem(t[0]);try{return i()}catch(e){}}}e.removeItem(t+a)}}})}console.error("You are using a development build. Make sure to use the correct build in production\nhttps://axios-cache-interceptor.js.org/guide/getting-started\n\n"),module.exports=t})();
//# sourceMappingURL=index.cjs.map