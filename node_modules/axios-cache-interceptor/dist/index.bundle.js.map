{"version":3,"file":"index.bundle.js","names":["headers: Record<string, string | true>","parse","header: CacheControl","defaultHeaderInterpreter: HeaderInterpreter","cacheControl: unknown","parse","age: unknown","expires: unknown","resolve!: Deferred<T>['resolve']","reject!: Deferred<T>['reject']","sourceValue: string | undefined","targetValue: string | undefined","result: Record<string, string | undefined>","predicate","etagValue: string | undefined","lastModifiedValue: string","onFulfilled: RequestInterceptor['onFulfilled']","parseVary","compareVary","cachedResponse: CachedResponse","deferred","deferred","error","onFulfilled: ResponseInterceptor['onFulfilled']","staleTtl: number | undefined","parseVary","newCache: CachedStorageValue","onRejected: ResponseInterceptor['onRejected']","parse","StateEvictionOrder: Record<StorageValue['state'], number>","clone: <T>(value: T) => T","key","pairs: [unknown, unknown][]","toHash: string","ok","error","allValues: [string, StorageValue][]","key","value","error"],"sources":["../node_modules/.pnpm/cache-parser@1.2.6/node_modules/cache-parser/src/internal.ts","../node_modules/.pnpm/cache-parser@1.2.6/node_modules/cache-parser/src/util.ts","../node_modules/.pnpm/cache-parser@1.2.6/node_modules/cache-parser/src/parse.ts","../src/header/headers.ts","../src/header/interpreter.ts","../node_modules/.pnpm/fast-defer@1.1.9/node_modules/fast-defer/src/internal.ts","../node_modules/.pnpm/fast-defer@1.1.9/node_modules/fast-defer/src/create-deferred.ts","../node_modules/.pnpm/http-vary@1.0.3/node_modules/http-vary/src/compare.ts","../node_modules/.pnpm/http-vary@1.0.3/node_modules/http-vary/src/parse.ts","../src/header/extract.ts","../src/util/cache-predicate.ts","../src/interceptors/util.ts","../src/interceptors/request.ts","../src/util/update-cache.ts","../src/interceptors/response.ts","../src/storage/build.ts","../src/storage/memory.ts","../node_modules/.pnpm/object-code@2.0.0/node_modules/object-code/src/util.ts","../node_modules/.pnpm/object-code@2.0.0/node_modules/object-code/src/hash.ts","../src/util/key-generator.ts","../src/cache/create.ts","../node_modules/.pnpm/try@1.0.3/node_modules/try/lib/index.js","../src/storage/web-api.ts"],"sourcesContent":["/** @internal */\nexport const cacheControlSymbol = Symbol('cache-parser');\n","export function isDuration(val: unknown): boolean {\n  return (\n    (typeof val === 'string' || typeof val === 'number') &&\n    // biome-ignore lint/suspicious/noAssignInExpressions: to reduce one line\n    (val = Number(val)) >= 0 &&\n    (val as number) < Number.POSITIVE_INFINITY\n  );\n}\n\nexport function isTruthy(val: unknown): boolean {\n  return (\n    val === true ||\n    typeof val === 'number' ||\n    (typeof val === 'string' && val !== 'false')\n  );\n}\n\nexport function parseRawHeaders(headerStr: string): Record<string, string | true> {\n  const headers: Record<string, string | true> = {};\n  const tokens = headerStr.toLowerCase().replace(/\\s+/g, '').split(',');\n\n  for (const token of tokens) {\n    const split = token.split('=', 2) as [string, string];\n    headers[split[0]] = split[1] ?? true;\n  }\n\n  return headers;\n}\n","import type { CacheControl } from './index';\nimport { cacheControlSymbol } from './internal';\nimport { isDuration, isTruthy, parseRawHeaders } from './util';\n\nconst number = Number;\n\n/**\n * Parses the Cache-Control header.\n *\n * You can check if a object was returned by this function with {@link isCacheControl} .\n *\n * @param {string} Header The header to parse\n * @returns {CacheControl} The parsed cache control header\n */\nexport function parse(headerStr?: string): CacheControl {\n  const header: CacheControl = Object.defineProperty({}, cacheControlSymbol, {\n    enumerable: false,\n    value: 1\n  });\n\n  if (!headerStr || typeof headerStr !== 'string') {\n    return header;\n  }\n\n  const headers = parseRawHeaders(headerStr);\n\n  const maxAge = headers['max-age'];\n  const maxStale = headers['max-stale'];\n  const minFresh = headers['min-fresh'];\n  const sMaxAge = headers['s-maxage'];\n  const staleIfError = headers['stale-if-error'];\n  const staleWhileRevalidate = headers['stale-while-revalidate'];\n\n  if (isTruthy(headers.immutable)) {\n    header.immutable = true;\n  }\n\n  if (isDuration(maxAge)) {\n    header.maxAge = number(maxAge);\n  }\n\n  if (isDuration(maxStale)) {\n    header.maxStale = number(maxStale);\n  }\n\n  if (isDuration(minFresh)) {\n    header.minFresh = number(minFresh);\n  }\n\n  if (isTruthy(headers['must-revalidate'])) {\n    header.mustRevalidate = true;\n  }\n\n  if (isTruthy(headers['must-understand'])) {\n    header.mustUnderstand = true;\n  }\n\n  if (isTruthy(headers['no-cache'])) {\n    header.noCache = true;\n  }\n\n  if (isTruthy(headers['no-store'])) {\n    header.noStore = true;\n  }\n\n  if (isTruthy(headers['no-transform'])) {\n    header.noTransform = true;\n  }\n\n  if (isTruthy(headers['only-if-cached'])) {\n    header.onlyIfCached = true;\n  }\n\n  if (isTruthy(headers.private)) {\n    header.private = true;\n  }\n\n  if (isTruthy(headers['proxy-revalidate'])) {\n    header.proxyRevalidate = true;\n  }\n\n  if (isTruthy(headers.public)) {\n    header.public = true;\n  }\n\n  if (isDuration(sMaxAge)) {\n    header.sMaxAge = number(sMaxAge);\n  }\n\n  if (isDuration(staleIfError)) {\n    header.staleIfError = number(staleIfError);\n  }\n\n  if (isDuration(staleWhileRevalidate)) {\n    header.staleWhileRevalidate = number(staleWhileRevalidate);\n  }\n\n  return header;\n}\n","/**\n * @deprecated This constant will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport const Header = {\n  /**\n   * ```txt\n   * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n   */\n  IfModifiedSince: 'if-modified-since',\n\n  /**\n   * ```txt\n   * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n   */\n  LastModified: 'last-modified',\n\n  /**\n   * ```txt\n   * If-None-Match: \"<etag_value>\"\n   * If-None-Match: \"<etag_value>\", \"<etag_value>\", â€¦\n   * If-None-Match: *\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n   */\n  IfNoneMatch: 'if-none-match',\n\n  /**\n   * ```txt\n   * Cache-Control: max-age=604800\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n   */\n  CacheControl: 'cache-control',\n\n  /**\n   * ```txt\n   * Pragma: no - cache;\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma\n   */\n  Pragma: 'pragma',\n\n  /**\n   * ```txt\n   * ETag: W / '<etag_value>';\n   * ETag: '<etag_value>';\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n   */\n  ETag: 'etag',\n\n  /**\n   * ```txt\n   * Expires: <http-date>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n   */\n  Expires: 'expires',\n\n  /**\n   * ```txt\n   * Age: <delta-seconds>\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n   */\n  Age: 'age',\n\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state Contains a string of ASCII characters that can be used as ETag for\n   * `If-Match` header Provided by user using `cache.etag` value.\n   *\n   * ```txt\n   * X-Axios-Cache-Etag: \"<etag_value>\"\n   * ```\n   */\n  XAxiosCacheEtag: 'x-axios-cache-etag',\n\n  /**\n   * Used internally as metadata to mark the cache item as revalidatable and enabling\n   * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n   * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n   * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n   * timestamp can be used for `If-Modified-Since` header.\n   *\n   * ```txt\n   * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n   * X-Axios-Cache-Last-Modified: use-cache-timestamp\n   * ```\n   */\n  XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n\n  /**\n   * Used internally as metadata to mark the cache item able to be used if the server\n   * returns an error. The stale-if-error response directive indicates that the cache can\n   * reuse a stale response when any error occurs.\n   *\n   * ```txt\n   * XAxiosCacheStaleIfError: <seconds>\n   * ```\n   */\n  XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error',\n\n  /**\n   * Indicates which request headers affect the response content.\n   * Used to prevent cache poisoning when responses differ based on request headers.\n   *\n   * ```txt\n   * Vary: Authorization\n   * Vary: Authorization, Accept-Language\n   * Vary: *\n   * ```\n   *\n   * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Vary\n   */\n  Vary: 'vary'\n} as const;\n","import { parse } from 'cache-parser';\nimport { Header } from './headers.js';\nimport type { HeaderInterpreter } from './types.js';\n\n/**\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport const defaultHeaderInterpreter: HeaderInterpreter = (headers, location) => {\n  if (!headers) return 'not enough headers';\n\n  const cacheControl: unknown = headers[Header.CacheControl];\n\n  if (cacheControl) {\n    const cc = parse(String(cacheControl));\n\n    if (\n      // Header told that this response should not be cached.\n      cc.noCache ||\n      cc.noStore ||\n      // Server side handling private data\n      (location === 'server' && cc.private)\n    ) {\n      return 'dont cache';\n    }\n\n    if (cc.immutable) {\n      // 1 year is sufficient, as Infinity may cause problems with certain storages.\n      // It might not be the best way, but a year is better than none. Facebook shows\n      // that a browser session stays at the most 1 month.\n      return {\n        cache: 1000 * 60 * 60 * 24 * 365\n      };\n    }\n\n    if (cc.maxAge !== undefined) {\n      const age: unknown = headers[Header.Age];\n\n      return {\n        cache: age\n          ? // If age is present, we must subtract it from maxAge\n            (cc.maxAge - Number(age)) * 1000\n          : cc.maxAge * 1000,\n        // Already out of date, must be requested again\n        stale:\n          // I couldn't find any documentation about who should be used, as they\n          // are not meant to overlap each other. But, as we cannot request in the\n          // background, as the stale-while-revalidate says, and we just increase\n          // its staleTtl when its present, max-stale is being preferred over\n          // stale-while-revalidate.\n          cc.maxStale !== undefined\n            ? cc.maxStale * 1000\n            : cc.staleWhileRevalidate !== undefined\n              ? cc.staleWhileRevalidate * 1000\n              : undefined\n      };\n    }\n  }\n\n  const expires: unknown = headers[Header.Expires];\n\n  if (expires) {\n    const milliseconds = Date.parse(String(expires)) - Date.now();\n    return milliseconds >= 0 ? { cache: milliseconds } : 'dont cache';\n  }\n\n  return 'not enough headers';\n};\n","/** @internal */\nexport const fastDeferSymbol = Symbol();\n","import type { Deferred } from './deferred';\nimport { fastDeferSymbol } from './internal';\n\n/** @returns A new {@link Deferred} object */\nexport function deferred<T>() {\n  let resolve!: Deferred<T>['resolve'];\n  let reject!: Deferred<T>['reject'];\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  }) as Deferred<T>;\n\n  promise.resolve = resolve;\n  promise.reject = reject;\n  promise[fastDeferSymbol] = 1;\n\n  return promise;\n}\n","import type { CompareHeaders, VaryHeader } from './types';\n\n/**\n * Checks if {@linkcode source} and {@linkcode target} headers are equivalent for the given\n * Vary header, as per\n * {@link https://www.rfc-editor.org/rfc/rfc9110.html#name-vary RFC 9110 Section 12.5.5}.\n *\n * This function determines if two requests would receive the same cached response based\n * on the Vary header requirements.\n *\n * @remarks\n * - Returns `false` for wildcard vary (`'*'`) as responses always differ\n * - Header name matching is case-insensitive (per RFC 9110)\n * - Missing headers are treated as `undefined`\n * - String values are trimmed before comparison\n * - Array values are converted to strings via `.toString()`\n * - Uses loose equality (!=) for comparison\n * - Empty strings are distinct from missing headers\n *\n * @example\n *\n * ```ts\n * const vary = ['accept-encoding', 'user-agent'];\n * const headers1 = { 'Accept-Encoding': 'gzip', 'User-Agent': 'Chrome' };\n * const headers2 = { 'Accept-Encoding': 'gzip', 'User-Agent': 'Chrome' };\n *\n * compare(vary, headers1, headers2);\n * // => true\n * ```\n *\n * @param {VaryHeader | null} vary - The Vary header specifying which fields to compare\n * @param {CompareHeaders} source - The first set of request headers\n * @param {CompareHeaders} target - The second set of request headers\n * @returns {boolean} `true` if the headers are equivalent for the given Vary header,\n *   `false` otherwise\n */\nexport function compare(\n  vary: VaryHeader | null,\n  source: CompareHeaders,\n  target: CompareHeaders\n): boolean {\n  // Wildcard and null always differ\n  if (vary === '*' || vary === null) {\n    return false;\n  }\n\n  const sourceKeys = Object.keys(source);\n  const targetKeys = Object.keys(target);\n\n  for (const field of vary) {\n    let sourceValue: string | undefined;\n    let targetValue: string | undefined;\n\n    // Case-insensitive header lookup in source\n    for (const key of sourceKeys) {\n      if (key.toLowerCase() === field) {\n        sourceValue = source[key]?.toString()?.trim();\n        break;\n      }\n    }\n\n    // Case-insensitive header lookup in target\n    for (const key of targetKeys) {\n      if (key.toLowerCase() === field) {\n        targetValue = target[key]?.toString()?.trim();\n        break;\n      }\n    }\n\n    // biome-ignore lint/suspicious/noDoubleEquals: Intentional loose comparison\n    if (sourceValue != targetValue) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import type { VaryHeader } from './types';\n\nconst VALID_HEADER_NAME_REGEX = /^[a-z0-9-]+$/i;\n\n/**\n * Parses the Vary header as defined in\n * {@link https://www.rfc-editor.org/rfc/rfc9110.html#name-vary RFC 9110 Section 12.5.5}.\n *\n * The Vary header indicates which request headers a server considers when selecting or\n * generating a response, enabling proper HTTP caching behavior.\n *\n * @remarks\n * - Header field names are normalized to lowercase\n * - Duplicate fields are automatically deduplicated\n * - Invalid header names (per RFC 9110) are silently skipped\n * - If the header contains `'*'`, the function returns `'*'` (wildcard)\n * - Returns `null` for invalid input or when no valid fields are found\n *\n * @example\n *\n * ```ts\n * parse('Accept-Encoding, User-Agent');\n * // => ['accept-encoding', 'user-agent']\n *\n * parse('*');\n * // => '*'\n *\n * parse('Invalid Header!');\n * // => null\n * ```\n *\n * @param {string} headerStr - The Vary header value to parse (e.g., \"Accept-Encoding,\n *   User-Agent\")\n * @param {number} [maxLength=16] - Maximum number of header fields to parse for DoS\n *   protection. Default is `16`\n * @returns {VaryHeader | null} The parsed Vary header as an array of lowercase field\n *   names, `'*'` for wildcard, or `null` if invalid.\n */\nexport function parse(headerStr?: string, maxLength = 16): VaryHeader | null {\n  // Invalid header name\n  if (typeof headerStr !== 'string') {\n    return null;\n  }\n\n  // RFC says only '*' is valid alone, but some servers may send invalid headers like '*, Accept-Encoding'\n  if (headerStr.includes('*')) {\n    return '*';\n  }\n\n  const values = new Set<string>();\n\n  for (let i = 0; i < headerStr.length; i++) {\n    const char = headerStr[i];\n\n    if (char === ' ' || char === '\\t' || char === ',') {\n      continue;\n    }\n\n    const start = i;\n\n    while (i < headerStr.length) {\n      const char = headerStr[i];\n\n      if (char === ',') {\n        break;\n      }\n\n      i++;\n    }\n\n    const headerName = headerStr.slice(start, i).trim().toLowerCase();\n\n    // Skip invalid header names\n    if (headerName.length === 0 || !VALID_HEADER_NAME_REGEX.test(headerName)) {\n      continue;\n    }\n\n    values.add(headerName);\n\n    // DOS protection to avoid overly large vary headers\n    if (values.size >= maxLength) {\n      break;\n    }\n  }\n\n  // Ensures no empty set is returned\n  if (values.size === 0) {\n    return null;\n  }\n\n  return Array.from(values);\n}\n","import type { AxiosRequestHeaders, AxiosResponseHeaders } from 'axios';\n\n/**\n * Extracts specified header values from request headers.\n * Generic utility for extracting a subset of headers.\n *\n * @param requestHeaders The full request headers object\n * @param headerNames Array of header names to extract\n * @returns Object with extracted header values\n */\nexport function extractHeaders(\n  requestHeaders: AxiosRequestHeaders | AxiosResponseHeaders,\n  headerNames: string[]\n): Record<string, string | undefined> {\n  const result: Record<string, string | undefined> = {};\n\n  for (const name of headerNames) {\n    result[name] = requestHeaders.get(name)?.toString();\n  }\n\n  return result;\n}\n","import type { CacheAxiosResponse } from '../cache/axios.js';\n\nimport type { CachePredicate, CachePredicateObject } from './types.js';\n\n/**\n * Tests an response against a {@link CachePredicateObject}.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport async function testCachePredicate<R = unknown, D = unknown>(\n  response: CacheAxiosResponse<R, D>,\n  predicate: CachePredicate<R, D>\n): Promise<boolean> {\n  if (typeof predicate === 'function') {\n    return predicate(response);\n  }\n\n  const { statusCheck, responseMatch, containsHeaders } = predicate;\n\n  if (\n    (statusCheck && !(await statusCheck(response.status))) ||\n    (responseMatch && !(await responseMatch(response)))\n  ) {\n    return false;\n  }\n\n  if (containsHeaders) {\n    for (const [header, predicate] of Object.entries(containsHeaders)) {\n      if (\n        !(await predicate(\n          // Avoid bugs in case the header is not in lower case\n          response.headers[header.toLowerCase()] ?? response.headers[header]\n        ))\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a given URL matches a specified pattern, which can be either a\n * string or a regular expression.\n *\n * @param matchPattern - The pattern to match against\n *\n *   - If it's a regular expression, it will be reset to ensure consistent behavior for\n *       stateful regular expressions.\n *   - If it's a string, the function checks if the URL contains the string.\n *\n * @param configUrl - The URL to test against the provided pattern; normally `config.url`.\n * @returns `true` if the `configUrl` matches the `matchPattern`\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function regexOrStringMatch(matchPattern: string | RegExp, configUrl: string) {\n  if (matchPattern instanceof RegExp) {\n    matchPattern.lastIndex = 0; // Reset the regex to ensure consistent matching\n    return matchPattern.test(configUrl);\n  }\n\n  return configUrl.includes(matchPattern);\n}\n","import type { Method } from 'axios';\nimport type {\n  CacheAxiosResponse,\n  CacheRequestConfig,\n  InternalCacheRequestConfig\n} from '../cache/axios.js';\nimport type { CacheProperties } from '../cache/cache.js';\nimport { Header } from '../header/headers.js';\nimport type {\n  CachedResponse,\n  MustRevalidateStorageValue,\n  StaleStorageValue\n} from '../storage/types.js';\n\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function createValidateStatus(\n  oldValidate?: CacheRequestConfig['validateStatus']\n): (status: number) => boolean {\n  return oldValidate\n    ? (status) => oldValidate(status) || status === 304\n    : (status) => (status >= 200 && status < 300) || status === 304;\n}\n\n/**\n * Checks if the given method is in the methods array\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function isMethodIn(\n  requestMethod: Method | string = 'get',\n  methodList: Method[] = []\n): boolean {\n  requestMethod = requestMethod.toLowerCase() as Lowercase<Method>;\n  return methodList.some((method) => method === requestMethod);\n}\n\n/**\n * @deprecated This interface will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport interface ConfigWithCache<D> extends InternalCacheRequestConfig<unknown, D> {\n  cache: Partial<CacheProperties<unknown, D>>;\n}\n\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function updateStaleRequest<D>(\n  cache: StaleStorageValue | MustRevalidateStorageValue,\n  config: ConfigWithCache<D>\n): void {\n  const { etag, modifiedSince } = config.cache;\n  const revalidation = cache.data?.meta?.revalidation;\n\n  // Handle ETag revalidation\n  if (etag) {\n    let etagValue: string | undefined;\n\n    if (revalidation?.etag) {\n      // Prefer meta value (new format)\n      etagValue = revalidation.etag;\n    } else if (etag === true) {\n      // Fallback to response ETag header (backward compatibility)\n      etagValue = cache.data?.headers[Header.ETag];\n    } else {\n      // Custom value from config\n      etagValue = etag;\n    }\n\n    if (etagValue) {\n      config.headers.set(Header.IfNoneMatch, etagValue);\n    }\n  }\n\n  // Handle Last-Modified revalidation\n  if (modifiedSince) {\n    let lastModifiedValue: string;\n\n    if (revalidation?.lastModified) {\n      // Prefer meta value (new format)\n      lastModifiedValue =\n        revalidation.lastModified === true\n          ? new Date(cache.createdAt).toUTCString()\n          : revalidation.lastModified;\n    } else if (modifiedSince === true) {\n      // Fallback to response Last-Modified header (backward compatibility)\n      lastModifiedValue =\n        cache.data.headers[Header.LastModified] || new Date(cache.createdAt).toUTCString();\n    } else {\n      // Custom Date from config\n      lastModifiedValue = modifiedSince.toUTCString();\n    }\n\n    config.headers.set(Header.IfModifiedSince, lastModifiedValue);\n  }\n}\n\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function createCacheResponse<R, D>(\n  response: CacheAxiosResponse<R, D>,\n  previousCache?: CachedResponse\n): CachedResponse {\n  if (response.status === 304 && previousCache) {\n    // Set the cache information into the response object\n    response.cached = true;\n    response.data = previousCache.data as R;\n    response.status = previousCache.status;\n    response.statusText = previousCache.statusText;\n\n    // Update possible new headers\n    response.headers = {\n      ...previousCache.headers,\n      ...response.headers\n    };\n\n    // return the old cache\n    return previousCache;\n  }\n\n  // New Response\n  return {\n    data: response.data,\n    status: response.status,\n    statusText: response.statusText,\n    headers: response.headers\n  };\n}\n","import { deferred } from 'fast-defer';\nimport { compare as compareVary, parse as parseVary } from 'http-vary';\nimport type { AxiosCacheInstance, CacheAxiosResponse } from '../cache/axios.js';\nimport { extractHeaders } from '../header/extract.js';\nimport { Header } from '../header/headers.js';\nimport type { CachedResponse, LoadingStorageValue } from '../storage/types.js';\nimport { regexOrStringMatch } from '../util/cache-predicate.js';\nimport type { RequestInterceptor } from './build.js';\nimport { createValidateStatus, isMethodIn, updateStaleRequest } from './util.js';\n\n/**\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function defaultRequestInterceptor(axios: AxiosCacheInstance): RequestInterceptor {\n  const onFulfilled: RequestInterceptor['onFulfilled'] = async (config) => {\n    config.id = axios.generateKey(config, {\n      vary:\n        config.cache && Array.isArray(config.cache.vary)\n          ? extractHeaders(config.headers, config.cache.vary)\n          : undefined\n    });\n\n    if (config.cache === false) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Cache disabled: config.cache === false'\n        });\n      }\n\n      return config;\n    }\n\n    // merge defaults with per request configuration\n    config.cache = { ...axios.defaults.cache, ...config.cache };\n\n    // Check if cache is disabled via enabled flag\n    if (config.cache.enabled === false) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Cache disabled: config.cache.enabled === false'\n        });\n      }\n\n      return config;\n    }\n\n    // ignoreUrls (blacklist)\n    if (\n      typeof config.cache.cachePredicate === 'object' &&\n      config.cache.cachePredicate.ignoreUrls &&\n      config.url\n    ) {\n      for (const url of config.cache.cachePredicate.ignoreUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: `URL ignored: matches ignoreUrls pattern`,\n              data: { url: config.url, pattern: url }\n            });\n          }\n\n          return config;\n        }\n      }\n    }\n\n    // allowUrls\n    if (\n      typeof config.cache.cachePredicate === 'object' &&\n      config.cache.cachePredicate.allowUrls &&\n      config.url\n    ) {\n      let matched = false;\n\n      for (const url of config.cache.cachePredicate.allowUrls) {\n        if (regexOrStringMatch(url, config.url)) {\n          matched = true;\n\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: `URL allowed: matches allowUrls pattern`,\n              data: { url: config.url, pattern: url }\n            });\n          }\n          break;\n        }\n      }\n\n      if (!matched) {\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: `URL rejected: not in allowUrls`,\n            data: { url: config.url, allowUrls: config.cache.cachePredicate.allowUrls }\n          });\n        }\n        return config;\n      }\n    }\n\n    // Applies sufficient headers to prevent other cache systems to work along with this one\n    //\n    // Its currently used before isMethodIn because if the isMethodIn returns false, the request\n    // shouldn't be cached an therefore neither in the browser.\n    // https://stackoverflow.com/a/2068407\n    if (config.cache.cacheTakeover) {\n      config.headers.set(\n        Header.CacheControl,\n        'no-cache, no-store, must-revalidate, max-age=0',\n        false\n      );\n      config.headers.set(Header.Pragma, 'no-cache', false);\n      config.headers.set(Header.Expires, '0', false);\n    }\n\n    if (!isMethodIn(config.method, config.cache.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: `Method ${config.method} not cacheable (allowed: ${config.cache.methods})`\n        });\n      }\n\n      return config;\n    }\n\n    // Assumes that the storage handled staled responses\n    let cache = await axios.storage.get(config.id, config);\n    const overrideCache = config.cache.override;\n\n    // Checks for vary mismatches in cached responses before proceeding\n    // If a vary mismatch is detected, it will generate a new key based on the\n    // current request headers and re-fetch the cache.\n    if (\n      // Vary enabled\n      config.cache.vary !== false &&\n      // Had vary headers in cached response (cached or stale)\n      cache.data?.meta?.vary &&\n      // Previous response had Vary header to use\n      cache.data.headers[Header.Vary]\n    ) {\n      const vary = Array.isArray(config.cache.vary)\n        ? config.cache.vary\n        : parseVary(cache.data.headers[Header.Vary]);\n\n      // Compares current request headers with cached vary headers (meta.vary)\n      if (vary && vary !== '*' && !compareVary(vary, cache.data.meta?.vary, config.headers)) {\n        // Generate base key without id field (otherwise returns config.id)\n        const extractedHeaders = extractHeaders(config.headers, vary);\n        const newKey = axios.generateKey({ ...config, id: undefined }, { vary: extractedHeaders });\n\n        // If ends up being a new key, change the cache to the new one\n        if (config.id !== newKey) {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: 'Vary mismatch, switching to vary-aware key',\n              data: {\n                cachedHeaders: cache.data.meta.vary,\n                currentHeaders: extractedHeaders,\n                vary,\n                newKey\n              }\n            });\n          }\n\n          config.id = newKey;\n          cache = await axios.storage.get(newKey, config);\n        }\n      }\n    }\n\n    // Not cached, continue the request, and mark it as fetching\n    // biome-ignore lint/suspicious/noConfusingLabels: required to break condition in simultaneous accesses\n    ignoreAndRequest: if (\n      cache.state === 'empty' ||\n      cache.state === 'stale' ||\n      cache.state === 'must-revalidate' ||\n      overrideCache\n    ) {\n      // This checks for simultaneous access to a new key. The js event loop jumps on the\n      // first await statement, so the second (asynchronous call) request may have already\n      // started executing.\n      if (axios.waiting.has(config.id) && !overrideCache) {\n        cache = await axios.storage.get(config.id, config);\n\n        // This check is required when a request has it own cache deleted manually, lets\n        // say by a `axios.storage.delete(key)` and has a concurrent loading request.\n        // Because in this case, the cache will be empty and may still has a pending key\n        // on waiting map.\n        if (cache.state !== 'empty' && cache.state !== 'must-revalidate') {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: 'Concurrent request found, reusing result'\n            });\n          }\n\n          break ignoreAndRequest;\n        }\n      }\n\n      // Create a deferred to resolve other requests for the same key when it's completed\n      const def = deferred<void>();\n      axios.waiting.set(config.id, def);\n\n      // Adds a default reject handler to catch when the request gets aborted without\n      // others waiting for it.\n      def.catch(() => undefined);\n\n      await axios.storage.set(\n        config.id,\n        {\n          state: 'loading',\n          previous: overrideCache\n            ? // Simply determine if the request is stale or not\n              // based if it had previous data or not\n              cache.data\n              ? 'stale'\n              : 'empty'\n            : // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'\n              (cache.state as 'stale' | 'must-revalidate'),\n\n          data: cache.data as any,\n\n          // If the cache is empty and asked to override it, use the current timestamp\n          createdAt: overrideCache && !cache.createdAt ? Date.now() : (cache.createdAt as any)\n        },\n        config\n      );\n\n      // Skip adding conditional headers (If-None-Match, If-Modified-Since) when override is true.\n      // The override option is meant to bypass cache and get fresh data, not revalidate existing cache.\n      // Adding conditional headers would cause the server to return 304 Not Modified instead of fresh data.\n      if ((cache.state === 'stale' || cache.state === 'must-revalidate') && !overrideCache) {\n        updateStaleRequest(cache, { ...config, cache: config.cache });\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: 'Stale revalidation: added conditional headers (If-None-Match/If-Modified-Since)'\n          });\n        }\n      }\n\n      config.validateStatus = createValidateStatus(config.validateStatus);\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Making network request',\n          data: { overrideCache, cacheState: cache.state }\n        });\n      }\n\n      // Hydrates any UI temporarily, if cache is available\n      if (cache.state === 'stale' || (cache.data && cache.state !== 'must-revalidate')) {\n        await config.cache.hydrate?.(cache);\n      }\n\n      return config;\n    }\n\n    let cachedResponse: CachedResponse;\n\n    if (cache.state === 'loading') {\n      const deferred = axios.waiting.get(config.id);\n\n      // The deferred may not exists when the process is using a persistent\n      // storage and cancelled  in the middle of a request, this would result in\n      // a pending loading state in the storage but no current promises to resolve\n      if (!deferred) {\n        // Hydrates any UI temporarily, if cache is available\n        if (cache.data) {\n          await config.cache.hydrate?.(cache);\n        }\n\n        return config;\n      }\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: config.id,\n          msg: 'Concurrent request detected, waiting...'\n        });\n      }\n\n      try {\n        // Deferred can't reuse the value because the user's storage might clone\n        // or mutate the value, so we need to ask it again.\n        // For example with memoryStorage + cloneData\n        await deferred;\n        const state = await axios.storage.get(config.id, config);\n\n        // This is a cache mismatch and should never happen, but in case it does,\n        // we need to redo the request all over again.\n        /* c8 ignore start */\n        if (!state.data) {\n          if (__ACI_DEV__) {\n            axios.debug({\n              id: config.id,\n              msg: 'Concurrent request completed without data, retrying'\n            });\n          }\n\n          return onFulfilled!(config);\n        }\n        /* c8 ignore end */\n\n        // After waiting, check if this request's vary headers match the cached variant\n        // If mismatch, don't use the cache - make own request to prevent cache poisoning\n        if (\n          config.cache.vary !== false &&\n          state.data.meta?.vary &&\n          state.data.headers[Header.Vary]\n        ) {\n          const vary = Array.isArray(config.cache.vary)\n            ? config.cache.vary\n            : parseVary(state.data.headers[Header.Vary]);\n\n          // Compare vary headers - if mismatch, make own request\n          if (vary && vary !== '*' && !compareVary(vary, state.data.meta.vary, config.headers)) {\n            if (__ACI_DEV__) {\n              axios.debug({\n                id: config.id,\n                msg: 'Vary mismatch after concurrent request, making own request',\n                data: {\n                  cachedVary: state.data.meta.vary,\n                  currentVary: extractHeaders(config.headers, vary)\n                }\n              });\n            }\n\n            // Don't use cached response - rerun interceptor logic but with new key\n            return onFulfilled!(config);\n          }\n        }\n\n        cachedResponse = state.data;\n      } catch (err) {\n        // The deferred was rejected by the first request that encountered an error.\n        // All deduplicated requests waiting on this deferred should fail with the same error\n        // to maintain consistency and prevent multiple network retries for the same resource.\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: config.id,\n            msg: 'Concurrent request failed, propagating error',\n            data: err\n          });\n        }\n\n        throw err;\n      }\n    } else {\n      cachedResponse = cache.data;\n    }\n\n    // The cached data is already transformed after receiving the response from the server.\n    // Reapplying the transformation on the transformed data will have an unintended effect.\n    // Since the cached data is already in the desired format, there is no need to apply the transformation function again.\n    config.transformResponse = undefined;\n\n    // Even though the response interceptor receives this one from here,\n    // it has been configured to ignore cached responses = true\n    config.adapter = function cachedAdapter(): Promise<CacheAxiosResponse> {\n      return Promise.resolve({\n        config,\n        data: cachedResponse.data,\n        headers: cachedResponse.headers,\n        status: cachedResponse.status,\n        statusText: cachedResponse.statusText,\n        cached: true,\n        stale: (cache as LoadingStorageValue).previous === 'stale',\n        id: config.id!\n      });\n    };\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: config.id,\n        msg: 'Using cached response'\n      });\n    }\n\n    return config;\n  };\n\n  return {\n    onFulfilled\n  };\n}\n","import type { CacheAxiosResponse } from '../cache/axios.js';\nimport type { AxiosStorage } from '../storage/types.js';\nimport type { CacheUpdater } from './types.js';\n\n/**\n * Function to update all caches, from CacheProperties.update, with the new data.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport async function updateCache<R, D>(\n  storage: AxiosStorage,\n  data: CacheAxiosResponse<R, D>,\n  cacheUpdater: CacheUpdater<R, D>\n): Promise<void> {\n  // Global cache update function.\n  if (typeof cacheUpdater === 'function') {\n    return cacheUpdater(data);\n  }\n\n  for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {\n    if (updater === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n\n    const value = await storage.get(cacheKey, data.config);\n\n    if (value.state === 'loading') {\n      continue;\n    }\n\n    const newValue = await updater(value, data);\n\n    if (newValue === 'delete') {\n      await storage.remove(cacheKey, data.config);\n      continue;\n    }\n\n    if (newValue !== 'ignore') {\n      await storage.set(cacheKey, newValue, data.config);\n    }\n  }\n}\n","import type { AxiosResponseHeaders } from 'axios';\nimport { parse } from 'cache-parser';\nimport { parse as parseVary } from 'http-vary';\nimport type { AxiosCacheInstance, CacheAxiosResponse, CacheRequestConfig } from '../cache/axios.js';\nimport type { CacheProperties } from '../cache/cache.js';\nimport { extractHeaders } from '../header/extract.js';\nimport { Header } from '../header/headers.js';\nimport type { CachedStorageValue } from '../storage/types.js';\nimport { testCachePredicate } from '../util/cache-predicate.js';\nimport { updateCache } from '../util/update-cache.js';\nimport type { ResponseInterceptor } from './build.js';\nimport { createCacheResponse, isMethodIn } from './util.js';\n\n/**\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport function defaultResponseInterceptor(axios: AxiosCacheInstance): ResponseInterceptor {\n  /**\n   * Replies a deferred stored in the axios waiting map. Use resolve to proceed checking the\n   * previously updated cache or reject to abort deduplicated requests with error.\n   */\n  const replyDeferred = (responseId: string, mode: 'reject' | 'resolve', error?: any) => {\n    // Rejects the deferred, if present\n    const deferred = axios.waiting.get(responseId);\n\n    if (deferred) {\n      deferred[mode](error);\n      axios.waiting.delete(responseId);\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: responseId,\n          msg: `Found waiting deferred(s) and ${mode} them`\n        });\n      }\n    }\n  };\n\n  const onFulfilled: ResponseInterceptor['onFulfilled'] = async (response) => {\n    // When response.config is not present, the response is indeed a error.\n    if (!response?.config) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'Unknown response received (not an Axios response)',\n          data: response\n        });\n      }\n\n      // Re-throws the error\n      throw response;\n    }\n\n    response.id = response.config.id!;\n    response.cached ??= false;\n\n    const config = response.config;\n    // Request interceptor merges defaults with per request configuration\n    const cacheConfig = config.cache as CacheProperties;\n\n    // Response is already cached\n    if (response.cached) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Returned cached response'\n        });\n      }\n\n      return response;\n    }\n\n    // Skip cache: either false or weird behavior\n    // config.cache should always exists, at least from global config merge.\n    if (!cacheConfig) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Response received without cache config',\n          data: response\n        });\n      }\n\n      response.cached = false;\n      return response;\n    }\n\n    // Update other entries before updating himself\n    if (cacheConfig.update) {\n      await updateCache(axios.storage, response, cacheConfig.update);\n    }\n\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: `Method ${config.method} not cacheable (allowed: ${cacheConfig.methods})`\n        });\n      }\n\n      return response;\n    }\n\n    const cache = await axios.storage.get(response.id, config);\n\n    if (\n      // If the request interceptor had a problem or it wasn't cached\n      cache.state !== 'loading'\n    ) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Response received but storage not in loading state',\n          data: { cacheState: cache.state }\n        });\n      }\n\n      // On limited storage scenarios, its possible the request was evicted while waiting\n      // for the response, in this case, state will be 'empty' again instead of loading.\n      // https://github.com/arthurfiorette/axios-cache-interceptor/issues/833\n      axios.waiting.delete(response.id);\n      return response;\n    }\n\n    // Config told that this response should not be cached.\n    if (\n      // For 'loading' values (previous: stale), this check already ran in the past.\n      !cache.data &&\n      !(await testCachePredicate(response, cacheConfig.cachePredicate))\n    ) {\n      replyDeferred(response.id, 'resolve');\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id: response.id,\n          msg: 'Cache predicate rejected this response'\n        });\n      }\n\n      return response;\n    }\n\n    // Avoid remnant headers from remote server to break implementation\n    for (const header of Object.keys(response.headers)) {\n      if (header.startsWith('x-axios-cache')) {\n        delete response.headers[header];\n      }\n    }\n\n    let ttl = cacheConfig.ttl || -1; // always set from global config\n    let staleTtl: number | undefined;\n\n    if (cacheConfig.interpretHeader) {\n      const expirationTime = axios.headerInterpreter(response.headers, axios.location);\n\n      // Cache should not be used\n      if (expirationTime === 'dont cache') {\n        replyDeferred(response.id, 'resolve');\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: response.id,\n            msg: 'Cache-Control header indicates: do not cache'\n          });\n        }\n\n        return response;\n      }\n\n      if (expirationTime !== 'not enough headers') {\n        if (typeof expirationTime === 'number') {\n          ttl = expirationTime;\n        } else {\n          ttl = expirationTime.cache;\n          staleTtl = expirationTime.stale;\n        }\n      }\n    }\n\n    if (typeof ttl === 'function') {\n      ttl = await ttl(response);\n    }\n\n    const data = createCacheResponse(response, cache.data);\n\n    // Store revalidation metadata in meta.revalidation (single source of truth)\n    if (cacheConfig.etag || cacheConfig.modifiedSince) {\n      data.meta ??= {};\n      data.meta.revalidation = {};\n\n      // ETag: store response's ETag or custom value\n      if (cacheConfig.etag) {\n        const etag = cacheConfig.etag === true ? response.headers[Header.ETag] : cacheConfig.etag;\n        if (etag) {\n          data.meta.revalidation.etag = etag;\n        }\n      }\n\n      // Last-Modified: store response's Last-Modified, cache timestamp (true), or custom date\n      if (cacheConfig.modifiedSince) {\n        data.meta.revalidation.lastModified =\n          cacheConfig.modifiedSince === true\n            ? response.headers[Header.LastModified] || true\n            : cacheConfig.modifiedSince.toUTCString();\n      }\n    }\n\n    // Either stales response (Vary *) or sets request Vary headers into metadata\n    if (cacheConfig.vary !== false && response.headers[Header.Vary]) {\n      const vary = Array.isArray(cacheConfig.vary)\n        ? cacheConfig.vary\n        : parseVary(response.headers[Header.Vary]);\n\n      // For valid values, store the subset of request headers in the cache response\n      if (Array.isArray(vary)) {\n        data.meta ??= {};\n        data.meta.vary = extractHeaders(config.headers, vary);\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: response.id,\n            msg: 'Storing response with Vary metadata',\n            data: { vary, extracted: data.meta.vary }\n          });\n        }\n\n        // RFC States * must revalidate every time per RFC 9110.\n      } else if (vary === '*') {\n        if (__ACI_DEV__) {\n          axios.debug({\n            id: response.id,\n            msg: 'Vary: * detected, storing as stale'\n          });\n        }\n\n        // Marks cache as stale immediately\n        await axios.storage.set(\n          response.id,\n          {\n            state: 'stale',\n            createdAt: Date.now(),\n            data,\n            ttl\n          },\n          config\n        );\n\n        replyDeferred(response.id, 'resolve');\n        return response;\n      }\n    }\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: response.id,\n        msg: 'Caching response',\n        data: { ttl, staleTtl, interpretHeader: cacheConfig.interpretHeader }\n      });\n    }\n\n    const newCache: CachedStorageValue = {\n      state: 'cached',\n      ttl,\n      staleTtl,\n      createdAt: Date.now(),\n      data\n    };\n\n    // Define this key as cache on the storage\n    await axios.storage.set(response.id, newCache, config);\n    replyDeferred(response.id, 'resolve');\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id: response.id,\n        msg: 'Response cached successfully',\n        data: { state: newCache.state, ttl: newCache.ttl }\n      });\n    }\n\n    // Return the response with cached as false, because it was not cached at all\n    return response;\n  };\n\n  const onRejected: ResponseInterceptor['onRejected'] = async (error) => {\n    // When response.config is not present, the response is indeed a error.\n    if (!error.isAxiosError || !error.config) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'FATAL: Non-Axios error in response interceptor',\n          data: error\n        });\n      }\n\n      // We should probably re-request the response to avoid an infinite loading state here\n      // but, since this is an unknown error, we cannot figure out what request ID to use.\n      // And the only solution is to let the storage actively reject the current loading state.\n      throw error;\n    }\n\n    const config = error.config as CacheRequestConfig & { headers: AxiosResponseHeaders };\n    const id = config.id;\n    const cacheConfig = config.cache as CacheProperties;\n    const response = error.response as CacheAxiosResponse | undefined;\n\n    // config.cache should always exist, at least from global config merge.\n    if (!cacheConfig || !id) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          msg: 'Request failed without cache config',\n          data: { error }\n        });\n      }\n\n      throw error;\n    }\n\n    if (!isMethodIn(config.method, cacheConfig.methods)) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: `Method ${config.method} not cacheable (allowed: ${cacheConfig.methods})`\n        });\n      }\n\n      // Rejects all other requests waiting for this response\n      await axios.storage.remove(id, config);\n      replyDeferred(id, 'reject', error);\n\n      throw error;\n    }\n\n    const cache = await axios.storage.get(id, config);\n\n    if (\n      // This will only not be loading if the interceptor broke\n      cache.state !== 'loading' ||\n      cache.previous !== 'stale'\n    ) {\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: 'Request error with unexpected cache state',\n          data: {\n            cacheState: cache.state,\n            previous: cache.state === 'loading' ? cache.previous : undefined,\n            errorCode: error.code\n          }\n        });\n      }\n\n      // Do not clear cache if this request is cached, but the request was cancelled before returning the cached response\n      if (\n        error.code !== 'ERR_CANCELED' ||\n        (error.code === 'ERR_CANCELED' && cache.state !== 'cached')\n      ) {\n        await axios.storage.remove(id, config);\n      }\n\n      // Rejects all other requests waiting for this response\n      replyDeferred(id, 'reject', error);\n\n      throw error;\n    }\n\n    if (cacheConfig.staleIfError) {\n      const cacheControl = String(response?.headers[Header.CacheControl]);\n      const staleHeader = cacheControl && parse(cacheControl).staleIfError;\n\n      const staleIfError =\n        typeof cacheConfig.staleIfError === 'function'\n          ? await cacheConfig.staleIfError(response, cache, error)\n          : cacheConfig.staleIfError === true && staleHeader\n            ? staleHeader * 1000 //staleIfError is in seconds\n            : cacheConfig.staleIfError;\n\n      if (__ACI_DEV__) {\n        axios.debug({\n          id,\n          msg: 'staleIfError config found for failed request',\n          data: { staleIfError, createdAt: cache.createdAt }\n        });\n      }\n\n      if (\n        staleIfError === true ||\n        // staleIfError is the number of seconds that stale is allowed to be used\n        (typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now())\n      ) {\n        // re-mark the cache as stale\n        await axios.storage.set(\n          id,\n          {\n            state: 'stale',\n            createdAt: Date.now(),\n            data: cache.data\n          },\n          config\n        );\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting.get(id);\n\n        if (waiting) {\n          waiting.resolve();\n          axios.waiting.delete(id);\n\n          if (__ACI_DEV__) {\n            axios.debug({\n              id,\n              msg: 'Found waiting deferred(s) and resolved them'\n            });\n          }\n        }\n\n        if (__ACI_DEV__) {\n          axios.debug({\n            id,\n            msg: 'staleIfError: returning stale cache for failed request'\n          });\n        }\n\n        return {\n          cached: true,\n          stale: true,\n          config,\n          id,\n          data: cache.data.data,\n          headers: cache.data.headers,\n          status: cache.data.status,\n          statusText: cache.data.statusText\n        };\n      }\n    }\n\n    if (__ACI_DEV__) {\n      axios.debug({\n        id,\n        msg: 'Unhandled error, cleaning up',\n        data: { errorCode: error.code, errorMessage: error.message }\n      });\n    }\n\n    // Rejects all other requests waiting for this response\n    await axios.storage.remove(id, config);\n    replyDeferred(id, 'reject', error);\n\n    throw error;\n  };\n\n  return {\n    onFulfilled,\n    onRejected\n  };\n}\n","import type { CacheRequestConfig } from '../cache/axios.js';\nimport { Header } from '../header/headers.js';\nimport type { MaybePromise } from '../util/types.js';\nimport type {\n  AxiosStorage,\n  CachedResponse,\n  CachedStorageValue,\n  StaleStorageValue,\n  StorageValue\n} from './types.js';\n\n/**\n * Returns true if the provided object was created from {@link buildStorage} function.\n *\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport const isStorage = (obj: unknown): obj is AxiosStorage =>\n  !!obj && !!(obj as Record<string, boolean>)['is-storage'];\n\n/**\n * Migrates old header-based revalidation data to new meta.revalidation format.\n * This ensures backward compatibility with existing cache entries.\n *\n * @deprecated Internal migration function. Will be removed when all cache entries\n * have naturally expired and been recreated with new format.\n */\nfunction migrateRevalidationHeaders(data: CachedResponse): void {\n  // Skip if already has meta.revalidation\n  if (data.meta?.revalidation) {\n    return;\n  }\n\n  const oldEtag = data.headers[Header.XAxiosCacheEtag];\n  const oldLastModified = data.headers[Header.XAxiosCacheLastModified];\n\n  if (oldEtag || oldLastModified) {\n    data.meta ??= {};\n    data.meta.revalidation = {};\n\n    if (oldEtag) {\n      data.meta.revalidation.etag = oldEtag;\n    }\n\n    if (oldLastModified) {\n      data.meta.revalidation.lastModified =\n        oldLastModified === 'use-cache-timestamp' ? true : oldLastModified;\n    }\n\n    delete data.headers[Header.XAxiosCacheEtag];\n    delete data.headers[Header.XAxiosCacheLastModified];\n    delete data.headers[Header.XAxiosCacheStaleIfError];\n  }\n}\n\nfunction hasRevalidationMetadata(value: CachedStorageValue | StaleStorageValue): boolean {\n  // Migrate old entries on-the-fly\n  migrateRevalidationHeaders(value.data);\n\n  const headers = value.data.headers;\n  const revalidation = value.data.meta?.revalidation;\n\n  return (\n    // Standard HTTP revalidation headers\n    Header.ETag in headers ||\n    Header.LastModified in headers ||\n    // Revalidation metadata (new format)\n    !!(revalidation?.etag || revalidation?.lastModified)\n  );\n}\n\n/** Returns true if value must be revalidated */\nexport function mustRevalidate(value: CachedStorageValue | StaleStorageValue): boolean {\n  // Must revalidate is a special case and should not serve stale values\n  // We could use cache-control's parse function, but this is way faster and simpler\n  return String(value.data.headers[Header.CacheControl]).includes('must-revalidate');\n}\n\n/** Returns true if this has sufficient properties to stale instead of expire. */\nexport function canStale(value: CachedStorageValue): boolean {\n  if (hasRevalidationMetadata(value)) {\n    return true;\n  }\n\n  return (\n    value.state === 'cached' &&\n    value.staleTtl !== undefined &&\n    // Only allow stale values after the ttl is already in the past and the staleTtl is in the future.\n    // In cases that just createdAt + ttl > Date.now(), isn't enough because the staleTtl could be <= 0.\n    // This logic only returns true when Date.now() is between the (createdAt + ttl) and (createdAt + ttl + staleTtl).\n    // Following the example below:\n    // |--createdAt--:--ttl--:---staleTtl--->\n    // [        past        ][now is in here]\n    Math.abs(Date.now() - (value.createdAt + value.ttl)) <= value.staleTtl\n  );\n}\n\n/**\n * Checks if the provided cache is expired. You should also check if the cache\n * {@link canStale} and {@link mayUseStale}\n */\nexport function isExpired(value: CachedStorageValue | StaleStorageValue): boolean {\n  return value.ttl !== undefined && value.createdAt + value.ttl <= Date.now();\n}\n\n/**\n * Defines which storage states are evicted first when cleaning up the storage.\n */\nconst StateEvictionOrder: Record<StorageValue['state'], number> = {\n  empty: 0,\n  'must-revalidate': 1,\n  stale: 2,\n  cached: 3,\n  // loading states usually don't have any data and are the most important ones\n  // to keep around\n  loading: 4\n};\n\n/**\n * Is a comparator function that sorts storage entries by their eviction priority\n * and, in the same group, by older first.\n */\nexport function storageEntriesSorter(\n  [, a]: [string, StorageValue],\n  [, b]: [string, StorageValue]\n): number {\n  const stateDiff = StateEvictionOrder[a.state] - StateEvictionOrder[b.state];\n  if (stateDiff !== 0) return stateDiff;\n  return (a.createdAt || 0) - (b.createdAt || 0);\n}\n\n/**\n * Returns true if the storage entry can be removed according to its state and the\n * provided maxStaleAge.\n */\nexport function canRemoveStorageEntry(value: StorageValue, maxStaleAge: number): boolean {\n  switch (value.state) {\n    case 'loading':\n      return false;\n\n    case 'empty':\n    case 'must-revalidate':\n      return true;\n\n    case 'cached':\n      return isExpired(value) && !canStale(value);\n\n    case 'stale':\n      if (maxStaleAge !== undefined && value.ttl !== undefined) {\n        return Date.now() > value.createdAt + value.ttl + maxStaleAge;\n      }\n      return false;\n  }\n}\n\nexport interface BuildStorage extends Omit<AxiosStorage, 'get'> {\n  /**\n   * Returns the value for the given key. This method does not have to make checks for\n   * cache invalidation or anything. It just returns what was previous saved, if present.\n   *\n   * @param key The key to look for\n   * @param currentRequest The current {@link CacheRequestConfig}, if any\n   * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n   */\n  find: (\n    key: string,\n    currentRequest?: CacheRequestConfig\n  ) => MaybePromise<StorageValue | undefined>;\n}\n\n/**\n * All integrated storages are wrappers around the `buildStorage` function. External\n * libraries use it and if you want to build your own, `buildStorage` is the way to go!\n *\n * The exported `buildStorage` function abstracts the storage interface and requires a\n * super simple object to build the storage.\n *\n * **Note**: You can only create custom storages with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...},\n *   clear: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n *\n * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n */\nexport function buildStorage({ set, find, remove, clear }: BuildStorage): AxiosStorage {\n  return {\n    //@ts-expect-error - we don't want to expose this\n    'is-storage': 1,\n    set,\n    remove,\n    clear,\n    get: async (key, config) => {\n      let value = await find(key, config);\n\n      if (!value) {\n        return { state: 'empty' };\n      }\n\n      if (\n        value.state === 'empty' ||\n        value.state === 'loading' ||\n        value.state === 'must-revalidate'\n      ) {\n        return value;\n      }\n\n      // Migrate old x-axios-cache headers to meta.revalidation on-the-fly\n      if (value.state === 'cached' || value.state === 'stale') {\n        migrateRevalidationHeaders(value.data);\n      }\n\n      // Handle cached values\n      if (value.state === 'cached') {\n        if (!isExpired(value)) {\n          return value;\n        }\n\n        // Tries to stale expired value\n        if (!canStale(value)) {\n          await remove(key, config);\n          return { state: 'empty' };\n        }\n\n        value = {\n          state: 'stale',\n          createdAt: value.createdAt,\n          data: value.data,\n          ttl: value.staleTtl !== undefined ? value.staleTtl + value.ttl : undefined\n        };\n\n        await set(key, value, config);\n\n        // Must revalidate is a special case and should not serve stale values\n        if (mustRevalidate(value)) {\n          return { ...value, state: 'must-revalidate' };\n        }\n      }\n\n      // A second check in case the new stale value was created already expired.\n      if (!isExpired(value)) {\n        return value;\n      }\n\n      if (hasRevalidationMetadata(value)) {\n        return value;\n      }\n\n      await remove(key, config);\n      return { state: 'empty' };\n    }\n  };\n}\n","import { buildStorage, canRemoveStorageEntry, storageEntriesSorter } from './build.js';\nimport type { AxiosStorage, StorageValue } from './types.js';\n\n/* c8 ignore start */\n/**\n * Clones an object using the structured clone algorithm if available, otherwise it uses\n * JSON.parse(JSON.stringify(value)).\n */\nconst clone: <T>(value: T) => T =\n  // https://caniuse.com/mdn-api_structuredclone (10/18/2023 92.51%)\n  typeof structuredClone === 'function'\n    ? structuredClone\n    : (value) => JSON.parse(JSON.stringify(value));\n/* c8 ignore stop */\n\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n *\n * @param {boolean | 'double'} cloneData Use `true` if the data returned by `find()`\n *   should be cloned to avoid mutating the original data outside the `set()` method. Use\n *   `'double'` to also clone before saving value in storage using `set()`. Disabled is\n *   default\n * @param {number | false} cleanupInterval The interval in milliseconds to run a\n *   setInterval job of cleaning old entries. If false, the job will not be created.\n *   5 minutes (300_000) is default\n * @param {number | false} maxEntries The maximum number of entries to keep in the\n *   storage. Its hard to determine the size of the entries, so a smart FIFO order is used\n *   to determine eviction. If false, no check will be done and you may grow up memory\n *   usage. 1024 is default\n * @param {number} maxStaleAge The maximum age in milliseconds a stale entry can stay\n *   in the storage before being removed. Otherwise, stale-able entries would stay\n *   indefinitely causing a memory leak eventually. 1 hour (3_600_000) is default\n */\nexport function buildMemoryStorage(\n  cloneData: boolean | 'double' = false,\n  cleanupInterval: number | false = 5 * 60 * 1000,\n  maxEntries: number | false = 1024,\n  maxStaleAge: number = 60 * 60 * 1000\n) {\n  function sortedEntries() {\n    return Array.from(storage.data.entries()).sort(storageEntriesSorter);\n  }\n\n  const storage = buildStorage({\n    set: (key, value) => {\n      // More entries than allowed, evict oldest ones\n      if (maxEntries && storage.data.size >= maxEntries) {\n        storage.cleanup();\n\n        // After cleanup, if still at or over capacity, manually evict entries\n        if (storage.data.size >= maxEntries) {\n          for (const [key] of sortedEntries()) {\n            storage.data.delete(key);\n\n            if (storage.data.size < maxEntries) {\n              break;\n            }\n          }\n        }\n      }\n\n      // Clone the value before storing to prevent future mutations\n      // from affecting cached data.\n      storage.data.set(key, cloneData === 'double' ? clone(value) : value);\n    },\n\n    remove: (key) => {\n      storage.data.delete(key);\n    },\n\n    find: (key) => {\n      const value = storage.data.get(key);\n      return cloneData && value !== undefined ? clone(value) : value;\n    },\n\n    clear: () => {\n      storage.data.clear();\n    }\n  }) as MemoryStorage;\n\n  storage.data = new Map();\n\n  // When this program gets running for more than the specified interval, there's a good\n  // chance of it being a long-running process or at least have a lot of entries. Therefore,\n  // \"faster\" loop is more important than code readability.\n  storage.cleanup = () => {\n    for (const [key, value] of sortedEntries()) {\n      if (canRemoveStorageEntry(value, maxStaleAge)) {\n        storage.data.delete(key);\n      }\n    }\n  };\n\n  if (cleanupInterval) {\n    storage.cleaner = setInterval(storage.cleanup, cleanupInterval);\n\n    // Attempt to unref the interval to not block Node.js from exiting\n    if (typeof storage.cleaner === 'object' && 'unref' in storage.cleaner) {\n      storage.cleaner.unref();\n    }\n  }\n\n  return storage;\n}\n\nexport interface MemoryStorage extends AxiosStorage {\n  data: Map<string, StorageValue>;\n  /** The job responsible to cleaning old entries */\n  cleaner: ReturnType<typeof setInterval>;\n  /** Tries to remove any invalid entry from the memory */\n  cleanup: () => void;\n}\n","export function sortNumbers(a: string, b: string) {\n  return a > b ? 1 : -1;\n}\n\nexport function sortPairsByKey(a: [unknown, unknown], b: [unknown, unknown]) {\n  return sortNumbers(String(a[0]), String(b[0]));\n}\n\n/**\n * Fast mixing using DJB2-style algorithm with XOR. Bitwise operations are much faster\n * than modulo.\n */\nexport function mix(h: number, value: number): number {\n  return (h * 33) ^ value;\n}\n\n/**\n * Normalizes special numeric values to prevent collisions. Returns a safe integer\n * representation.\n */\nexport function normalizeNumber(val: number): number {\n  if (Number.isNaN(val)) return 0x7ff80000;\n  if (val === Infinity) return 0x7ff00000;\n  if (val === -Infinity) return 0xfff00000;\n\n  // For very large numbers, hash them as strings to avoid precision loss\n  if (Math.abs(val) > Number.MAX_SAFE_INTEGER) {\n    // Convert to string and hash the string representation\n    const str = String(val);\n    let h = 0;\n    for (let i = 0; i < str.length; i++) {\n      h = mix(h, str.charCodeAt(i));\n    }\n    return h;\n  }\n\n  return val;\n}\n","import { mix, normalizeNumber, sortNumbers, sortPairsByKey } from './util';\n\n/**\n * Hashes a given value into a unique number.\n *\n * This function accepts **ANY** kind of value, like `functions`, `classes`, `objects` and\n * so on.\n *\n * **Note**: Symbols uniqueness are not guaranteed, as they are transformed to strings.\n *\n * @example\n *\n * ```ts\n * class B {}\n *\n * const bHash = hash(B);\n * const bInstanceHash = hash(new B());\n * const bArrayHash = hash([B, new B(), new B(), { b: new B() }]);\n * const bBuilderHash = hash(() => B);\n * const bFactoryHash = hash(() => new B());\n * ```\n *\n * @param val The value to be hashed\n * @returns The signed integer result from the provided value\n * @see https://tinylibs.js.org/packages/object-code/\n */\nexport function hash(val: unknown, seen?: WeakSet<object>): number {\n  let h = 5381; // DJB2 seed\n\n  // Handle objects and array-like structures\n  if (typeof val === 'object' && val !== null) {\n    const hasEntries = typeof (val as any).entries === 'function';\n    const hasEnumerableKeys = Object.keys(val).length > 0;\n    const shouldHashAsObject =\n      val.toString === Object.prototype.toString ||\n      val.toString === Array.prototype.toString;\n\n    // Hash objects with enumerable keys OR entries() method (Map, Set, FormData, etc.)\n    if (shouldHashAsObject || (hasEntries && !hasEnumerableKeys)) {\n      if (!seen) {\n        seen = new WeakSet();\n      }\n      seen.add(val);\n\n      // Get key-value pairs: use entries() for special objects, Object.keys() for regular ones\n      const pairs: [unknown, unknown][] =\n        hasEntries && !hasEnumerableKeys\n          ? Array.from((val as any).entries())\n          : Object.keys(val)\n              .sort(sortNumbers)\n              .map((key) => [key, val[key as keyof typeof val]]);\n\n      // Sort by key for consistent hashing (only needed for entries() path)\n      if (hasEntries && !hasEnumerableKeys) {\n        pairs.sort(sortPairsByKey);\n      }\n\n      // Hash all key-value pairs\n      for (let i = 0; i < pairs.length; i++) {\n        const [key, value] = pairs[i]!;\n\n        h = mix(h, hash(key, seen));\n\n        // Track circular references for object values\n        if (\n          typeof value === 'object' &&\n          value !== null &&\n          (value.toString === Object.prototype.toString ||\n            value.toString === Array.prototype.toString)\n        ) {\n          if (seen.has(value)) {\n            continue;\n          }\n          seen.add(value);\n        }\n\n        h = mix(h, hash(value, seen));\n      }\n\n      // Hash the constructor for type differentiation\n      h = mix(h, hash(val.constructor, seen));\n\n      return h;\n    }\n  }\n\n  // Hash primitives efficiently - avoid string concatenation overhead\n  const type = typeof val;\n\n  // Hash the type first to differentiate types\n  for (let i = 0; i < type.length; i++) {\n    h = mix(h, type.charCodeAt(i));\n  }\n\n  if (val instanceof Date) {\n    // Hash dates by their numeric timestamp directly\n    return mix(h, val.getTime());\n  }\n\n  if (type === 'number') {\n    // Normalize special numbers to prevent collisions\n    return mix(h, normalizeNumber(val as number));\n  }\n\n  if (type === 'boolean') {\n    // Hash booleans as distinct values\n    return mix(h, val ? 1 : 0);\n  }\n\n  // For other types, get string representation\n  let toHash: string;\n\n  // Handles null prototype objects and symbols\n  try {\n    toHash = String(val);\n  } catch {\n    toHash = Object.prototype.toString.call(val);\n  }\n\n  // Hash the string representation\n  for (let i = 0; i < toHash.length; i++) {\n    h = mix(h, toHash.charCodeAt(i));\n  }\n\n  return h;\n}\n","import type { Method } from 'axios';\nimport { hash } from 'object-code';\nimport type { CacheRequestConfig } from '../cache/axios.js';\nimport type { CachedResponseMeta } from '../storage/types.js';\nimport type { KeyGenerator } from './types.js';\n\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and optional metadata,\n * and returns a value hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nexport function buildKeyGenerator<R = unknown, D = unknown>(\n  generator: (request: CacheRequestConfig<R, D>, meta?: CachedResponseMeta) => unknown\n): KeyGenerator<R, D> {\n  return (request, meta) => {\n    if (request.id) {\n      return request.id;\n    }\n\n    const key = generator(request, meta);\n\n    if (typeof key === 'string' || typeof key === 'number') {\n      return `${key}`;\n    }\n\n    return `${hash(key)}`;\n  };\n}\n\n/**\n * @deprecated This function will be hidden in future versions. Please tell us why you need it at https://github.com/arthurfiorette/axios-cache-interceptor/issues/1158\n */\nexport const defaultKeyGenerator = buildKeyGenerator(\n  ({ baseURL, url, method, params, data }, meta) => {\n    // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n    if (baseURL !== undefined) {\n      baseURL = baseURL.replace(SLASHES_REGEX, '');\n    } else {\n      // just to have a consistent hash\n      baseURL = '';\n    }\n\n    if (url !== undefined) {\n      url = url.replace(SLASHES_REGEX, '');\n    } else {\n      // just to have a consistent hash\n      url = '';\n    }\n\n    if (method !== undefined) {\n      method = method.toLowerCase() as Method;\n    } else {\n      // just to have a consistent hash\n      method = 'get';\n    }\n\n    return {\n      url: baseURL + (baseURL && url ? '/' : '') + url,\n      params,\n      method,\n      data,\n      ...meta\n    };\n  }\n);\n","import type { AxiosInstance } from 'axios';\nimport { defaultHeaderInterpreter } from '../header/interpreter.js';\nimport { defaultRequestInterceptor } from '../interceptors/request.js';\nimport { defaultResponseInterceptor } from '../interceptors/response.js';\nimport { isStorage } from '../storage/build.js';\nimport { buildMemoryStorage } from '../storage/memory.js';\nimport { defaultKeyGenerator } from '../util/key-generator.js';\nimport type { AxiosCacheInstance } from './axios.js';\nimport type { CacheInstance, CacheProperties } from './cache.js';\n\nexport interface CacheOptions extends Partial<CacheInstance>, Partial<CacheProperties> {}\n\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * ```ts\n * const axios = setupCache(axios, OPTIONS);\n * ```\n *\n * The `setupCache` function receives global options and all [request\n * specifics](https://axios-cache-interceptor.js.org/config/request-specifics) ones too.\n * This way, you can customize the defaults for all requests.\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n * @see https://axios-cache-interceptor.js.org/config\n */\nexport function setupCache(axios: AxiosInstance, options: CacheOptions = {}): AxiosCacheInstance {\n  const axiosCache = axios as AxiosCacheInstance;\n\n  if (axiosCache.defaults.cache) {\n    throw new Error('setupCache() should be called only once');\n  }\n\n  axiosCache.location = typeof window === 'undefined' ? 'server' : 'client';\n\n  axiosCache.storage = options.storage || buildMemoryStorage();\n\n  if (!isStorage(axiosCache.storage)) {\n    throw new Error('Use buildStorage() function');\n  }\n\n  axiosCache.waiting = options.waiting || new Map();\n\n  axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n\n  axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n\n  axiosCache.requestInterceptor =\n    options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n\n  axiosCache.responseInterceptor =\n    options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n\n  axiosCache.debug = options.debug || function noop() {};\n\n  // CacheRequestConfig values\n  axiosCache.defaults.cache = {\n    enabled: options.enabled ?? true,\n\n    update: options.update || {},\n\n    ttl: options.ttl ?? 1000 * 60 * 5,\n\n    // Although RFC 7231 also marks POST as cacheable, most users don't know that\n    // and may have problems about why their \"create X\" route not working.\n    methods: options.methods || ['get', 'head'],\n\n    cachePredicate: options.cachePredicate || {\n      // All cacheable status codes defined in RFC 7231\n      statusCheck: (status) => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status)\n    },\n\n    etag: options.etag ?? true,\n\n    // This option is going to be ignored by servers when ETag is enabled\n    // Checks strict equality to false to avoid undefined-ish values\n    modifiedSince: options.modifiedSince ?? options.etag === false,\n\n    interpretHeader: options.interpretHeader ?? true,\n\n    cacheTakeover: options.cacheTakeover ?? true,\n\n    staleIfError: options.staleIfError ?? true,\n\n    override: options.override ?? false,\n\n    hydrate: options.hydrate ?? undefined,\n\n    vary: options.vary ?? true\n  };\n\n  // Apply interceptors\n  axiosCache.interceptors.request.use(\n    axiosCache.requestInterceptor.onFulfilled,\n    axiosCache.requestInterceptor.onRejected\n  );\n  axiosCache.interceptors.response.use(\n    axiosCache.responseInterceptor.onFulfilled,\n    axiosCache.responseInterceptor.onRejected\n  );\n\n  return axiosCache;\n}\n","/// <reference path=\"./index.d.ts\" />\n\n/** @template V */\nexport class Result {\n  /**\n   * @param {boolean} ok\n   * @param {unknown} [error]\n   * @param {V} [value]\n   */\n  constructor(ok, error, value) {\n    this.ok = !!ok;\n\n    // must not set the other field to allow for\n    // 'error' in result checks\n    if (this.ok) {\n      this.value = value;\n    } else {\n      this.error = error;\n    }\n  }\n\n  *[Symbol.iterator]() {\n    yield this.ok;\n    yield this.error;\n    yield this.value;\n  }\n\n  /**\n   * @this void\n   * @template T\n   * @param {T} value\n   */\n  static ok(value) {\n    return new Result(true, undefined, value);\n  }\n\n  /**\n   * @this void\n   * @param {unknown} error\n   */\n  static error(error) {\n    return new Result(false, error);\n  }\n\n  /**\n   * @this void\n   * @template T\n   * @param {any} result\n   * @param {...any} args\n   * @returns {Promise<Result<T>> | Result<T>}\n   */\n  static try(result, ...args) {\n    // Wraps everything because `try` should never throw.\n    try {\n      // If syncFn() is passed directly, it throws before try() runs.\n      // To prevent this, wrap it in a function and unwrap its result.\n      if (typeof result === 'function') {\n        result = result.apply(undefined, args);\n      }\n\n      // Promises must return a valid Promise<Result<T>>\n      if (result instanceof Promise) {\n        return result.then(Result.ok, Result.error);\n      }\n\n      // If the result is not a function or a Promise, we can be sure its a success\n      return Result.ok(result);\n    } catch (error) {\n      return Result.error(error);\n    }\n  }\n}\n\n// Aliases\nexport const error = Result.error;\nexport const ok = Result.ok;\nexport const t = Result.try;\n","import { Result } from 'try';\nimport { buildStorage, canRemoveStorageEntry } from './build.js';\nimport type { StorageValue } from './types.js';\n\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n * @param {number} maxStaleAge The maximum age in milliseconds a stale entry can stay\n *   in the storage before being removed. Otherwise, stale-able entries would stay\n *   indefinitely causing a memory leak eventually. 1 hour (3_600_000) is default\n */\nexport function buildWebStorage(\n  storage: Storage,\n  prefix = 'axios-cache-',\n  maxStaleAge: number = 60 * 60 * 1000\n) {\n  function save(key: string, value: StorageValue) {\n    storage.setItem(prefix + key, JSON.stringify(value));\n  }\n\n  return buildStorage({\n    clear: () => {\n      for (const key in storage) {\n        if (key.startsWith(prefix)) {\n          storage.removeItem(key);\n        }\n      }\n    },\n\n    find: (key) => {\n      const json = storage.getItem(prefix + key);\n      return json ? (JSON.parse(json) as StorageValue) : undefined;\n    },\n\n    remove: (key) => {\n      storage.removeItem(prefix + key);\n    },\n\n    set: (key, value) => {\n      const result = Result.try(save, key, value);\n\n      if (result.ok) {\n        return;\n      }\n\n      // we cannot hide non quota errors\n      if (!isDomQuotaExceededError(result.error)) {\n        throw result.error;\n      }\n\n      const allValues: [string, StorageValue][] = Object.entries(storage as Record<string, string>)\n        .filter(([key]) => key.startsWith(prefix))\n        .map(([key, value]) => [key, JSON.parse(value) as StorageValue]);\n\n      // Remove all expired values\n      for (const [key, value] of allValues) {\n        if (canRemoveStorageEntry(value, maxStaleAge)) {\n          storage.removeItem(key);\n        }\n      }\n\n      // Try save again after removing expired values\n      const retry = Result.try(save, key, value);\n\n      if (retry.ok) {\n        return;\n      }\n\n      // we cannot hide non quota errors\n      if (!isDomQuotaExceededError(retry.error)) {\n        throw retry.error;\n      }\n\n      // Storage still full, try removing the oldest value until it can be saved\n\n      const descItems = allValues.sort((a, b) => (a[1].createdAt || 0) - (b[1].createdAt || 0));\n\n      // Keep looping until all items are removed or the save works\n      for (const item of descItems) {\n        storage.removeItem(item[0]);\n\n        const lastTry = Result.try(save, key, value);\n\n        if (lastTry.ok) {\n          return;\n        }\n\n        // we cannot hide non quota errors\n        if (!isDomQuotaExceededError(lastTry.error)) {\n          throw lastTry.error;\n        }\n      }\n\n      // Could not save even after removing all items, just ignore since its\n      // a storage quota issue.\n    }\n  });\n}\n\nfunction isDomQuotaExceededError(error: unknown): boolean {\n  // Check if it's a DOMException by duck-typing (works across different DOMException implementations)\n  const isDOMException =\n    error instanceof DOMException ||\n    (typeof error === 'object' &&\n      error !== null &&\n      'name' in error &&\n      error.constructor?.name === 'DOMException');\n\n  return (\n    isDOMException &&\n    // https://stackoverflow.com/a/23375082\n    'name' in (error as any) &&\n    ((error as any).name === 'QuotaExceededError' ||\n      (error as any).name === 'NS_ERROR_DOM_QUOTA_REACHED' ||\n      (error as any).name === 'QUOTA_EXCEEDED_ERR')\n  );\n}\n"],"x_google_ignoreList":[0,1,2,5,6,7,8,17,18,21],"mappings":"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"}