.map(async (src) => {


        /**
         * Download func
         */
        async function download(src: string) {
          // cancel github workflow
          if (typeof process.env.GITFLOW !== "undefined") return;

          // only download valid url
          if (src.match(/^https?:\/\//)) {
            // if url not local hexo domain
            if (!src.match(new RegExp("^https?://" + HexoURL.host))) {
              try {
                //console.log(`${chalk.magenta("[img][try]")} ${key}`);

        const download = bluebird.method(() => {
          return
        });
        return download()


              } catch (error) {
                const err: Error = error;
                libres.err = err.message;
              } finally {
                if (!downloadedKeys.includes(key)) downloadedKeys.push(key);

                // add result to `libraries`
                libraries[key] = libres;
                // save libraries
                writeFileSync(filesave, JSON.stringify(libraries));
              }
            } else {
              // set src as fullpath for local domain
              libres.fullpath = src;
            }
          }
        }

        // [download] if key not specified in `libraries`
        if (typeof libraries[key] === "undefined") {
          await download(src);
        }

        if (libres.file && !libres.err) {
          // check if downloaded file removed
          if (!existsSync(libres.file)) {
            await download(libres.url);
          }

          // add result to `libraries`
          libraries[key] = libres;
          // save libraries
          writeFileSync(filesave, JSON.stringify(libraries));
        }
        return libres;
      })
      .each((data) => {

      });