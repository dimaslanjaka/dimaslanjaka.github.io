{"version":3,"file":"dev/index.bundle.js","mappings":"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","sources":["webpack://AxiosCacheInterceptor/webpack/universalModuleDefinition","webpack://AxiosCacheInterceptor/webpack/bootstrap","webpack://AxiosCacheInterceptor/webpack/runtime/define property getters","webpack://AxiosCacheInterceptor/webpack/runtime/hasOwnProperty shorthand","webpack://AxiosCacheInterceptor/webpack/runtime/make namespace object","webpack://AxiosCacheInterceptor/./node_modules/.pnpm/cache-parser@1.2.4/node_modules/cache-parser/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/header/headers.ts","webpack://AxiosCacheInterceptor/./src/header/interpreter.ts","webpack://AxiosCacheInterceptor/./node_modules/.pnpm/fast-defer@1.1.8/node_modules/fast-defer/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/interceptors/util.ts","webpack://AxiosCacheInterceptor/./src/interceptors/request.ts","webpack://AxiosCacheInterceptor/./src/util/cache-predicate.ts","webpack://AxiosCacheInterceptor/./src/util/update-cache.ts","webpack://AxiosCacheInterceptor/./src/interceptors/response.ts","webpack://AxiosCacheInterceptor/./src/storage/build.ts","webpack://AxiosCacheInterceptor/./src/storage/memory.ts","webpack://AxiosCacheInterceptor/./node_modules/.pnpm/object-code@1.3.2/node_modules/object-code/dist/index.mjs","webpack://AxiosCacheInterceptor/./src/util/key-generator.ts","webpack://AxiosCacheInterceptor/./src/cache/create.ts","webpack://AxiosCacheInterceptor/./src/storage/web-api.ts","webpack://AxiosCacheInterceptor/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AxiosCacheInterceptor\"] = factory();\n\telse\n\t\troot[\"AxiosCacheInterceptor\"] = factory();\n})(typeof self !== 'undefined' ? self : this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var e=Symbol(\"cache-parser\");function a(e){return(\"string\"==typeof e||\"number\"==typeof e)&&(e=Number(e))>=0&&e<Infinity}function r(e){return!0===e||\"number\"==typeof e||\"string\"==typeof e&&\"false\"!==e}var t=Number;function s(s){var n=Object.defineProperty({},e,{enumerable:!1,value:1});if(!s||\"string\"!=typeof s)return n;var i=function(e){var a={},r=e.toLowerCase().replace(/\\s+/g,\"\").split(\",\");for(var t in r){var s,n=r[t].split(\"=\",2);a[n[0]]=null==(s=n[1])||s}return a}(s),u=i[\"max-age\"],l=i[\"max-stale\"],o=i[\"min-fresh\"],m=i[\"s-maxage\"],p=i[\"stale-if-error\"],h=i[\"stale-while-revalidate\"];return r(i.immutable)&&(n.immutable=!0),a(u)&&(n.maxAge=t(u)),a(l)&&(n.maxStale=t(l)),a(o)&&(n.minFresh=t(o)),r(i[\"must-revalidate\"])&&(n.mustRevalidate=!0),r(i[\"must-understand\"])&&(n.mustUnderstand=!0),r(i[\"no-cache\"])&&(n.noCache=!0),r(i[\"no-store\"])&&(n.noStore=!0),r(i[\"no-transform\"])&&(n.noTransform=!0),r(i[\"only-if-cached\"])&&(n.onlyIfCached=!0),r(i.private)&&(n.private=!0),r(i[\"proxy-revalidate\"])&&(n.proxyRevalidate=!0),r(i.public)&&(n.public=!0),a(m)&&(n.sMaxAge=t(m)),a(p)&&(n.staleIfError=t(p)),a(h)&&(n.staleWhileRevalidate=t(h)),n}function n(e){if(!e||\"object\"!=typeof e)return[];var t=[];return r(e.immutable)&&t.push(\"immutable\"),a(e.maxAge)&&t.push(\"max-age=\"+e.maxAge),a(e.maxStale)&&t.push(\"max-stale=\"+e.maxStale),a(e.minFresh)&&t.push(\"min-fresh=\"+e.minFresh),r(e.mustRevalidate)&&t.push(\"must-revalidate\"),r(e.mustUnderstand)&&t.push(\"must-understand\"),r(e.noCache)&&t.push(\"no-cache\"),r(e.noStore)&&t.push(\"no-store\"),r(e.noTransform)&&t.push(\"no-transform\"),r(e.onlyIfCached)&&t.push(\"only-if-cached\"),r(e.private)&&t.push(\"private\"),r(e.proxyRevalidate)&&t.push(\"proxy-revalidate\"),r(e.public)&&t.push(\"public\"),a(e.sMaxAge)&&t.push(\"s-maxage=\"+e.sMaxAge),a(e.staleIfError)&&t.push(\"stale-if-error=\"+e.staleIfError),a(e.staleWhileRevalidate)&&t.push(\"stale-while-revalidate=\"+e.staleWhileRevalidate),t}function i(a){return!!a&&!!a[e]}export{i as isCacheControl,s as parse,n as tokenize};\n//# sourceMappingURL=index.mjs.map\n","export const Header = Object.freeze({\n    /**\n     * ```txt\n     * If-Modified-Since: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Modified-Since\n     */\n    IfModifiedSince: 'if-modified-since',\n    /**\n     * ```txt\n     * Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Last-Modified\n     */\n    LastModified: 'last-modified',\n    /**\n     * ```txt\n     * If-None-Match: \"<etag_value>\"\n     * If-None-Match: \"<etag_value>\", \"<etag_value>\", â€¦\n     * If-None-Match: *\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match\n     */\n    IfNoneMatch: 'if-none-match',\n    /**\n     * ```txt\n     * Cache-Control: max-age=604800\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n     */\n    CacheControl: 'cache-control',\n    /**\n     * ```txt\n     * Pragma: no - cache;\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Pragma\n     */\n    Pragma: 'pragma',\n    /**\n     * ```txt\n     * ETag: W / '<etag_value>';\n     * ETag: '<etag_value>';\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag\n     */\n    ETag: 'etag',\n    /**\n     * ```txt\n     * Expires: <http-date>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Expires\n     */\n    Expires: 'expires',\n    /**\n     * ```txt\n     * Age: <delta-seconds>\n     * ```\n     *\n     * @link https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age\n     */\n    Age: 'age',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state Contains a string of ASCII characters that can be used as ETag for\n     * `If-Match` header Provided by user using `cache.etag` value.\n     *\n     * ```txt\n     * X-Axios-Cache-Etag: \"<etag_value>\"\n     * ```\n     */\n    XAxiosCacheEtag: 'x-axios-cache-etag',\n    /**\n     * Used internally as metadata to mark the cache item as revalidatable and enabling\n     * stale cache state may contain `'use-cache-timestamp'` if `cache.modifiedSince` is\n     * `true`, otherwise will contain a date from `cache.modifiedSince`. If a date is\n     * provided, it can be used for `If-Modified-Since` header, otherwise the cache\n     * timestamp can be used for `If-Modified-Since` header.\n     *\n     * ```txt\n     * X-Axios-Cache-Last-Modified: <day-name>, <day> <month> <year> <hour>:<minute>:<second> GMT\n     * X-Axios-Cache-Last-Modified: use-cache-timestamp\n     * ```\n     */\n    XAxiosCacheLastModified: 'x-axios-cache-last-modified',\n    /**\n     * Used internally as metadata to mark the cache item able to be used if the server\n     * returns an error. The stale-if-error response directive indicates that the cache can\n     * reuse a stale response when any error occurs.\n     *\n     * ```txt\n     * XAxiosCacheStaleIfError: <seconds>\n     * ```\n     */\n    XAxiosCacheStaleIfError: 'x-axios-cache-stale-if-error'\n});\n","import { parse } from 'cache-parser';\nimport { Header } from './headers';\nexport const defaultHeaderInterpreter = (headers) => {\n    if (!headers)\n        return 'not enough headers';\n    const cacheControl = headers[Header.CacheControl];\n    if (cacheControl) {\n        const { noCache, noStore, maxAge, maxStale, immutable, staleWhileRevalidate } = parse(String(cacheControl));\n        // Header told that this response should not be cached.\n        if (noCache || noStore) {\n            return 'dont cache';\n        }\n        if (immutable) {\n            // 1 year is sufficient, as Infinity may cause problems with certain storages.\n            // It might not be the best way, but a year is better than none. Facebook shows\n            // that a browser session stays at the most 1 month.\n            return {\n                cache: 1000 * 60 * 60 * 24 * 365\n            };\n        }\n        if (maxAge !== undefined) {\n            const age = headers[Header.Age];\n            return {\n                cache: age\n                    ? // If age is present, we must subtract it from maxAge\n                        (maxAge - Number(age)) * 1000\n                    : maxAge * 1000,\n                // Already out of date, must be requested again\n                stale: \n                // I couldn't find any documentation about who should be used, as they\n                // are not meant to overlap each other. But, as we cannot request in the\n                // background, as the stale-while-revalidate says, and we just increase\n                // its staleTtl when its present, max-stale is being preferred over\n                // stale-while-revalidate.\n                maxStale !== undefined\n                    ? maxStale * 1000\n                    : staleWhileRevalidate !== undefined\n                        ? staleWhileRevalidate * 1000\n                        : undefined\n            };\n        }\n    }\n    const expires = headers[Header.Expires];\n    if (expires) {\n        const milliseconds = Date.parse(String(expires)) - Date.now();\n        return milliseconds >= 0 ? { cache: milliseconds } : 'dont cache';\n    }\n    return 'not enough headers';\n};\n","var r=Symbol();function e(){var e,n,o=new Promise(function(r,o){e=r,n=o});return o.resolve=e,o.reject=n,o[r]=1,o}function n(e){return!!e&&!!e[r]}export{e as deferred,n as isDeferred};\n//# sourceMappingURL=index.mjs.map\n","import { Header } from '../header/headers';\n/**\n * Creates a new validateStatus function that will use the one already used and also\n * accept status code 304.\n */\nexport function createValidateStatus(oldValidate) {\n    return oldValidate\n        ? (status) => oldValidate(status) || status === 304\n        : (status) => (status >= 200 && status < 300) || status === 304;\n}\n/** Checks if the given method is in the methods array */\nexport function isMethodIn(requestMethod = 'get', methodList = []) {\n    requestMethod = requestMethod.toLowerCase();\n    return methodList.some((method) => method === requestMethod);\n}\n/**\n * This function updates the cache when the request is stale. So, the next request to the\n * server will be made with proper header / settings.\n */\nexport function updateStaleRequest(cache, config) {\n    var _a;\n    config.headers || (config.headers = {});\n    const { etag, modifiedSince } = config.cache;\n    if (etag) {\n        const etagValue = etag === true ? (_a = cache.data) === null || _a === void 0 ? void 0 : _a.headers[Header.ETag] : etag;\n        if (etagValue) {\n            config.headers[Header.IfNoneMatch] = etagValue;\n        }\n    }\n    if (modifiedSince) {\n        config.headers[Header.IfModifiedSince] =\n            modifiedSince === true\n                ? // If last-modified is not present, use the createdAt timestamp\n                    cache.data.headers[Header.LastModified] ||\n                        new Date(cache.createdAt).toUTCString()\n                : modifiedSince.toUTCString();\n    }\n}\n/**\n * Creates the new date to the cache by the provided response. Also handles possible 304\n * Not Modified by updating response properties.\n */\nexport function createCacheResponse(response, previousCache) {\n    if (response.status === 304 && previousCache) {\n        // Set the cache information into the response object\n        response.cached = true;\n        response.data = previousCache.data;\n        response.status = previousCache.status;\n        response.statusText = previousCache.statusText;\n        // Update possible new headers\n        response.headers = Object.assign(Object.assign({}, previousCache.headers), response.headers);\n        // return the old cache\n        return previousCache;\n    }\n    // New Response\n    return {\n        data: response.data,\n        status: response.status,\n        statusText: response.statusText,\n        headers: response.headers\n    };\n}\n","import { deferred } from 'fast-defer';\nimport { Header } from '../header/headers';\nimport { createValidateStatus, isMethodIn, updateStaleRequest } from './util';\nexport function defaultRequestInterceptor(axios) {\n    const onFulfilled = async (config) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        var _k, _l, _m, _o, _p, _q;\n        config.id = axios.generateKey(config);\n        if (config.cache === false) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: config.id,\n                    msg: 'Ignoring cache because config.cache === false',\n                    data: config\n                });\n            }\n            return config;\n        }\n        // merge defaults with per request configuration\n        config.cache = Object.assign(Object.assign({}, axios.defaults.cache), config.cache);\n        if (typeof config.cache.cachePredicate === 'object' &&\n            config.cache.cachePredicate.ignoreUrls &&\n            config.url) {\n            for (const url of config.cache.cachePredicate.ignoreUrls) {\n                if (url instanceof RegExp\n                    ? // Handles stateful regexes\n                        // biome-ignore lint: reduces the number of checks\n                        ((url.lastIndex = 0), url.test(config.url))\n                    : config.url.includes(url)) {\n                    if (__ACI_DEV__) {\n                        axios.debug({\n                            id: config.id,\n                            msg: `Ignored because url (${config.url}) matches ignoreUrls (${config.cache.cachePredicate.ignoreUrls})`,\n                            data: {\n                                url: config.url,\n                                cachePredicate: config.cache.cachePredicate\n                            }\n                        });\n                    }\n                    return config;\n                }\n            }\n        }\n        // Applies sufficient headers to prevent other cache systems to work along with this one\n        //\n        // Its currently used before isMethodIn because if the isMethodIn returns false, the request\n        // shouldn't be cached an therefore neither in the browser.\n        if (config.cache.cacheTakeover) {\n            (_a = (_k = config.headers)[_l = Header.CacheControl]) !== null && _a !== void 0 ? _a : (_k[_l] = 'no-cache');\n            (_b = (_m = config.headers)[_o = Header.Pragma]) !== null && _b !== void 0 ? _b : (_m[_o] = 'no-cache');\n            (_c = (_p = config.headers)[_q = Header.Expires]) !== null && _c !== void 0 ? _c : (_p[_q] = '0');\n        }\n        if (!isMethodIn(config.method, config.cache.methods)) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: config.id,\n                    msg: `Ignored because method (${config.method}) is not in cache.methods (${config.cache.methods})`\n                });\n            }\n            return config;\n        }\n        // Assumes that the storage handled staled responses\n        let cache = await axios.storage.get(config.id, config);\n        const overrideCache = config.cache.override;\n        // Not cached, continue the request, and mark it as fetching\n        // biome-ignore lint/suspicious/noConfusingLabels: required to break condition in simultaneous accesses\n        ignoreAndRequest: if (cache.state === 'empty' || cache.state === 'stale' || overrideCache) {\n            // This checks for simultaneous access to a new key. The js event loop jumps on the\n            // first await statement, so the second (asynchronous call) request may have already\n            // started executing.\n            if (axios.waiting[config.id] && !overrideCache) {\n                cache = (await axios.storage.get(config.id, config));\n                // @ts-expect-error This check is required when a request has it own cache deleted manually, lets\n                // say by a `axios.storage.delete(key)` and has a concurrent loading request.\n                // Because in this case, the cache will be empty and may still has a pending key\n                // on waiting map.\n                if (cache.state !== 'empty') {\n                    if (__ACI_DEV__) {\n                        axios.debug({\n                            id: config.id,\n                            msg: 'Waiting list had an deferred for this key, waiting for it to finish'\n                        });\n                    }\n                    break ignoreAndRequest;\n                }\n            }\n            // Create a deferred to resolve other requests for the same key when it's completed\n            axios.waiting[config.id] = deferred();\n            // Adds a default reject handler to catch when the request gets aborted without\n            // others waiting for it.\n            axios.waiting[config.id].catch(() => undefined);\n            await axios.storage.set(config.id, {\n                state: 'loading',\n                previous: overrideCache\n                    ? // Simply determine if the request is stale or not\n                        // based if it had previous data or not\n                        cache.data\n                            ? 'stale'\n                            : 'empty'\n                    : // Typescript doesn't know that cache.state here can only be 'empty' or 'stale'\n                        cache.state,\n                data: cache.data,\n                // If the cache is empty and asked to override it, use the current timestamp\n                createdAt: overrideCache && !cache.createdAt ? Date.now() : cache.createdAt\n            }, config);\n            if (cache.state === 'stale') {\n                updateStaleRequest(cache, config);\n                if (__ACI_DEV__) {\n                    axios.debug({\n                        id: config.id,\n                        msg: 'Updated stale request'\n                    });\n                }\n            }\n            config.validateStatus = createValidateStatus(config.validateStatus);\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: config.id,\n                    msg: 'Sending request, waiting for response',\n                    data: {\n                        overrideCache,\n                        state: cache.state\n                    }\n                });\n            }\n            // Hydrates any UI temporarily, if cache is available\n            if (cache.state === 'stale' || cache.data) {\n                await ((_e = (_d = config.cache).hydrate) === null || _e === void 0 ? void 0 : _e.call(_d, cache));\n            }\n            return config;\n        }\n        let cachedResponse;\n        if (cache.state === 'loading') {\n            const deferred = axios.waiting[config.id];\n            // The deferred may not exists when the process is using a persistent\n            // storage and cancelled  in the middle of a request, this would result in\n            // a pending loading state in the storage but no current promises to resolve\n            if (!deferred) {\n                // Hydrates any UI temporarily, if cache is available\n                if (cache.data) {\n                    await ((_g = (_f = config.cache).hydrate) === null || _g === void 0 ? void 0 : _g.call(_f, cache));\n                }\n                return config;\n            }\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: config.id,\n                    msg: 'Detected concurrent request, waiting for it to finish'\n                });\n            }\n            try {\n                cachedResponse = await deferred;\n            }\n            catch (err) {\n                if (__ACI_DEV__) {\n                    axios.debug({\n                        id: config.id,\n                        msg: 'Deferred rejected, requesting again',\n                        data: err\n                    });\n                }\n                // Hydrates any UI temporarily, if cache is available\n                /* c8 ignore next 3 */\n                if (cache.data) {\n                    await ((_j = (_h = config.cache).hydrate) === null || _j === void 0 ? void 0 : _j.call(_h, cache));\n                }\n                // The deferred is rejected when the request that we are waiting rejects its cache.\n                // In this case, we need to redo the request all over again.\n                return onFulfilled(config);\n            }\n        }\n        else {\n            cachedResponse = cache.data;\n        }\n        // Even though the response interceptor receives this one from here,\n        // it has been configured to ignore cached responses = true\n        config.adapter = function cachedAdapter() {\n            return Promise.resolve({\n                config,\n                data: cachedResponse.data,\n                headers: cachedResponse.headers,\n                status: cachedResponse.status,\n                statusText: cachedResponse.statusText,\n                cached: true,\n                id: config.id\n            });\n        };\n        if (__ACI_DEV__) {\n            axios.debug({\n                id: config.id,\n                msg: 'Returning cached response'\n            });\n        }\n        return config;\n    };\n    return {\n        onFulfilled,\n        apply: () => axios.interceptors.request.use(onFulfilled)\n    };\n}\n","/** Tests an response against a {@link CachePredicateObject}. */\nexport async function testCachePredicate(response, predicate) {\n    var _a;\n    if (typeof predicate === 'function') {\n        return predicate(response);\n    }\n    const { statusCheck, responseMatch, containsHeaders } = predicate;\n    if ((statusCheck && !(await statusCheck(response.status))) ||\n        (responseMatch && !(await responseMatch(response)))) {\n        return false;\n    }\n    if (containsHeaders) {\n        for (const [header, predicate] of Object.entries(containsHeaders)) {\n            if (!(await predicate(\n            // Avoid bugs in case the header is not in lower case\n            (_a = response.headers[header.toLowerCase()]) !== null && _a !== void 0 ? _a : response.headers[header]))) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n","/** Function to update all caches, from CacheProperties.update, with the new data. */\nexport async function updateCache(storage, data, cacheUpdater) {\n    // Global cache update function.\n    if (typeof cacheUpdater === 'function') {\n        return cacheUpdater(data);\n    }\n    for (const [cacheKey, updater] of Object.entries(cacheUpdater)) {\n        if (updater === 'delete') {\n            await storage.remove(cacheKey, data.config);\n            continue;\n        }\n        const value = await storage.get(cacheKey, data.config);\n        if (value.state === 'loading') {\n            continue;\n        }\n        const newValue = await updater(value, data);\n        if (newValue === 'delete') {\n            await storage.remove(cacheKey, data.config);\n            continue;\n        }\n        if (newValue !== 'ignore') {\n            await storage.set(cacheKey, newValue, data.config);\n        }\n    }\n}\n","import { parse } from 'cache-parser';\nimport { Header } from '../header/headers';\nimport { testCachePredicate } from '../util/cache-predicate';\nimport { updateCache } from '../util/update-cache';\nimport { createCacheResponse, isMethodIn } from './util';\nexport function defaultResponseInterceptor(axios) {\n    /**\n     * Rejects cache for an response response.\n     *\n     * Also update the waiting list for this key by rejecting it.\n     */\n    const rejectResponse = async (responseId, config) => {\n        var _a;\n        // Updates the cache to empty to prevent infinite loading state\n        await axios.storage.remove(responseId, config);\n        // Rejects the deferred, if present\n        (_a = axios.waiting[responseId]) === null || _a === void 0 ? void 0 : _a.reject();\n        delete axios.waiting[responseId];\n    };\n    const onFulfilled = async (response) => {\n        var _a;\n        // When response.config is not present, the response is indeed a error.\n        if (!(response === null || response === void 0 ? void 0 : response.config)) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    msg: 'Response interceptor received an unknown response.',\n                    data: response\n                });\n            }\n            // Re-throws the error\n            throw response;\n        }\n        response.id = response.config.id;\n        (_a = response.cached) !== null && _a !== void 0 ? _a : (response.cached = false);\n        const config = response.config;\n        // Request interceptor merges defaults with per request configuration\n        const cacheConfig = config.cache;\n        // Response is already cached\n        if (response.cached) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: 'Returned cached response'\n                });\n            }\n            return response;\n        }\n        // Skip cache: either false or weird behavior\n        // config.cache should always exists, at least from global config merge.\n        if (!cacheConfig) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: 'Response with config.cache falsy',\n                    data: response\n                });\n            }\n            response.cached = false;\n            return response;\n        }\n        // Update other entries before updating himself\n        if (cacheConfig.update) {\n            await updateCache(axios.storage, response, cacheConfig.update);\n        }\n        if (!isMethodIn(config.method, cacheConfig.methods)) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: `Ignored because method (${config.method}) is not in cache.methods (${cacheConfig.methods})`,\n                    data: { config, cacheConfig }\n                });\n            }\n            return response;\n        }\n        const cache = await axios.storage.get(response.id, config);\n        if (\n        // If the request interceptor had a problem or it wasn't cached\n        cache.state !== 'loading') {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: \"Response not cached and storage isn't loading\",\n                    data: { cache, response }\n                });\n            }\n            return response;\n        }\n        // Config told that this response should be cached.\n        if (\n        // For 'loading' values (previous: stale), this check already ran in the past.\n        !cache.data &&\n            !(await testCachePredicate(response, cacheConfig.cachePredicate))) {\n            await rejectResponse(response.id, config);\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: 'Cache predicate rejected this response'\n                });\n            }\n            return response;\n        }\n        // Avoid remnant headers from remote server to break implementation\n        for (const header of Object.keys(response.headers)) {\n            if (header.startsWith('x-axios-cache')) {\n                delete response.headers[header];\n            }\n        }\n        if (cacheConfig.etag && cacheConfig.etag !== true) {\n            response.headers[Header.XAxiosCacheEtag] = cacheConfig.etag;\n        }\n        if (cacheConfig.modifiedSince) {\n            response.headers[Header.XAxiosCacheLastModified] =\n                cacheConfig.modifiedSince === true\n                    ? 'use-cache-timestamp'\n                    : cacheConfig.modifiedSince.toUTCString();\n        }\n        let ttl = cacheConfig.ttl || -1; // always set from global config\n        let staleTtl;\n        if (cacheConfig.interpretHeader) {\n            const expirationTime = axios.headerInterpreter(response.headers);\n            // Cache should not be used\n            if (expirationTime === 'dont cache') {\n                await rejectResponse(response.id, config);\n                if (__ACI_DEV__) {\n                    axios.debug({\n                        id: response.id,\n                        msg: `Cache header interpreted as 'dont cache'`,\n                        data: { cache, response, expirationTime }\n                    });\n                }\n                return response;\n            }\n            if (expirationTime !== 'not enough headers') {\n                if (typeof expirationTime === 'number') {\n                    ttl = expirationTime;\n                }\n                else {\n                    ttl = expirationTime.cache;\n                    staleTtl = expirationTime.stale;\n                }\n            }\n        }\n        const data = createCacheResponse(response, cache.data);\n        if (typeof ttl === 'function') {\n            ttl = await ttl(response);\n        }\n        if (cacheConfig.staleIfError) {\n            response.headers[Header.XAxiosCacheStaleIfError] = String(ttl);\n        }\n        if (__ACI_DEV__) {\n            axios.debug({\n                id: response.id,\n                msg: 'Useful response configuration found',\n                data: { cacheConfig, cacheResponse: data }\n            });\n        }\n        const newCache = {\n            state: 'cached',\n            ttl,\n            staleTtl,\n            createdAt: Date.now(),\n            data\n        };\n        // Resolve all other requests waiting for this response\n        const waiting = axios.waiting[response.id];\n        if (waiting) {\n            waiting.resolve(newCache.data);\n            delete axios.waiting[response.id];\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id: response.id,\n                    msg: 'Found waiting deferred(s) and resolved them'\n                });\n            }\n        }\n        // Define this key as cache on the storage\n        await axios.storage.set(response.id, newCache, config);\n        if (__ACI_DEV__) {\n            axios.debug({\n                id: response.id,\n                msg: 'Response cached',\n                data: { cache: newCache, response }\n            });\n        }\n        // Return the response with cached as false, because it was not cached at all\n        return response;\n    };\n    const onRejected = async (error) => {\n        var _a;\n        // When response.config is not present, the response is indeed a error.\n        if (!error.isAxiosError || !error.config) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    msg: 'FATAL: Received an non axios error in the rejected response interceptor, ignoring.',\n                    data: error\n                });\n            }\n            // We should probably re-request the response to avoid an infinite loading state here\n            // but, since this is an unknown error, we cannot figure out what request ID to use.\n            // And the only solution is to let the storage actively reject the current loading state.\n            throw error;\n        }\n        const config = error.config;\n        const id = config.id;\n        const cacheConfig = config.cache;\n        const response = error.response;\n        // config.cache should always exist, at least from global config merge.\n        if (!cacheConfig || !id) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    msg: 'Web request returned an error but cache handling is not enabled',\n                    data: { error }\n                });\n            }\n            throw error;\n        }\n        if (!isMethodIn(config.method, cacheConfig.methods)) {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id,\n                    msg: `Ignored because method (${config.method}) is not in cache.methods (${cacheConfig.methods})`,\n                    data: { config, cacheConfig }\n                });\n            }\n            // Rejects all other requests waiting for this response\n            await rejectResponse(id, config);\n            throw error;\n        }\n        const cache = await axios.storage.get(id, config);\n        if (\n        // This will only not be loading if the interceptor broke\n        cache.state !== 'loading' ||\n            cache.previous !== 'stale') {\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id,\n                    msg: 'Caught an error in the request interceptor',\n                    data: { cache, error, config }\n                });\n            }\n            // Rejects all other requests waiting for this response\n            await rejectResponse(id, config);\n            throw error;\n        }\n        if (cacheConfig.staleIfError) {\n            const cacheControl = String(response === null || response === void 0 ? void 0 : response.headers[Header.CacheControl]);\n            const staleHeader = cacheControl && parse(cacheControl).staleIfError;\n            const staleIfError = typeof cacheConfig.staleIfError === 'function'\n                ? await cacheConfig.staleIfError(response, cache, error)\n                : cacheConfig.staleIfError === true && staleHeader\n                    ? staleHeader * 1000 //staleIfError is in seconds\n                    : cacheConfig.staleIfError;\n            if (__ACI_DEV__) {\n                axios.debug({\n                    id,\n                    msg: 'Found cache if stale config for rejected response',\n                    data: { error, config, staleIfError }\n                });\n            }\n            if (staleIfError === true ||\n                // staleIfError is the number of seconds that stale is allowed to be used\n                (typeof staleIfError === 'number' && cache.createdAt + staleIfError > Date.now())) {\n                // Resolve all other requests waiting for this response\n                (_a = axios.waiting[id]) === null || _a === void 0 ? void 0 : _a.resolve(cache.data);\n                delete axios.waiting[id];\n                // re-mark the cache as stale\n                await axios.storage.set(id, {\n                    state: 'stale',\n                    createdAt: Date.now(),\n                    data: cache.data\n                }, config);\n                if (__ACI_DEV__) {\n                    axios.debug({\n                        id,\n                        msg: 'staleIfError resolved this response with cached data',\n                        data: { error, config, cache }\n                    });\n                }\n                return {\n                    cached: true,\n                    config,\n                    id,\n                    data: cache.data.data,\n                    headers: cache.data.headers,\n                    status: cache.data.status,\n                    statusText: cache.data.statusText\n                };\n            }\n        }\n        if (__ACI_DEV__) {\n            axios.debug({\n                id,\n                msg: 'Received an unknown error that could not be handled',\n                data: { error, config }\n            });\n        }\n        // Rejects all other requests waiting for this response\n        await rejectResponse(id, config);\n        throw error;\n    };\n    return {\n        onFulfilled,\n        onRejected,\n        apply: () => axios.interceptors.response.use(onFulfilled, onRejected)\n    };\n}\n","import { Header } from '../header/headers';\n/** Returns true if the provided object was created from {@link buildStorage} function. */\nexport const isStorage = (obj) => !!obj && !!obj['is-storage'];\nfunction hasUniqueIdentifierHeader(value) {\n    const headers = value.data.headers;\n    return (Header.ETag in headers ||\n        Header.LastModified in headers ||\n        Header.XAxiosCacheEtag in headers ||\n        Header.XAxiosCacheLastModified in headers);\n}\n/** Returns true if this has sufficient properties to stale instead of expire. */\nexport function canStale(value) {\n    // Must revalidate is a special case and should not be staled\n    if (String(value.data.headers[Header.CacheControl])\n        // We could use cache-control's parse function, but this is way faster and simpler\n        .includes('must-revalidate')) {\n        return false;\n    }\n    if (hasUniqueIdentifierHeader(value)) {\n        return true;\n    }\n    return (value.state === 'cached' &&\n        value.staleTtl !== undefined &&\n        // Only allow stale values after the ttl is already in the past and the staleTtl is in the future.\n        // In cases that just createdAt + ttl > Date.now(), isn't enough because the staleTtl could be <= 0.\n        // This logic only returns true when Date.now() is between the (createdAt + ttl) and (createdAt + ttl + staleTtl).\n        // Following the example below:\n        // |--createdAt--:--ttl--:---staleTtl--->\n        // [        past        ][now is in here]\n        Math.abs(Date.now() - (value.createdAt + value.ttl)) <= value.staleTtl);\n}\n/**\n * Checks if the provided cache is expired. You should also check if the cache\n * {@link canStale}\n */\nexport function isExpired(value) {\n    return value.ttl !== undefined && value.createdAt + value.ttl <= Date.now();\n}\n/**\n * All integrated storages are wrappers around the `buildStorage` function. External\n * libraries use it and if you want to build your own, `buildStorage` is the way to go!\n *\n * The exported `buildStorage` function abstracts the storage interface and requires a\n * super simple object to build the storage.\n *\n * **Note**: You can only create an custom storage with this function.\n *\n * @example\n *\n * ```js\n * const myStorage = buildStorage({\n *   find: () => {...},\n *   set: () => {...},\n *   remove: () => {...}\n * });\n *\n * const axios = setupCache(axios, { storage: myStorage });\n * ```\n *\n * @see https://axios-cache-interceptor.js.org/guide/storages#buildstorage\n */\nexport function buildStorage({ set, find, remove }) {\n    return {\n        //@ts-expect-error - we don't want to expose this\n        'is-storage': 1,\n        set,\n        remove,\n        get: async (key, config) => {\n            let value = await find(key, config);\n            if (!value) {\n                return { state: 'empty' };\n            }\n            if (value.state === 'empty' || value.state === 'loading') {\n                return value;\n            }\n            // Handle cached values\n            if (value.state === 'cached') {\n                if (!isExpired(value)) {\n                    return value;\n                }\n                // Tries to stale expired value\n                if (!canStale(value)) {\n                    await remove(key, config);\n                    return { state: 'empty' };\n                }\n                value = {\n                    state: 'stale',\n                    createdAt: value.createdAt,\n                    data: value.data,\n                    ttl: value.staleTtl !== undefined ? value.staleTtl + value.ttl : undefined\n                };\n                await set(key, value, config);\n            }\n            // A second check in case the new stale value was created already expired.\n            if (!isExpired(value)) {\n                return value;\n            }\n            if (hasUniqueIdentifierHeader(value)) {\n                return value;\n            }\n            await remove(key, config);\n            return { state: 'empty' };\n        }\n    };\n}\n","import { buildStorage, canStale, isExpired } from './build';\n/**\n * Creates a simple in-memory storage. This means that if you need to persist data between\n * page or server reloads, this will not help.\n *\n * This is the storage used by default.\n *\n * If you need to modify it's data, you can do by the `data` property.\n *\n * @example\n *\n * ```js\n * const memoryStorage = buildMemoryStorage();\n *\n * setupCache(axios, { storage: memoryStorage });\n *\n * // Simple example to force delete the request cache\n *\n * const { id } = axios.get('url');\n *\n * delete memoryStorage.data[id];\n * ```\n *\n * @param {boolean | 'double'} cloneData Use `true` if the data returned by `find()`\n *   should be cloned to avoid mutating the original data outside the `set()` method. Use\n *   `'double'` to also clone before saving value in storage using `set()`. Disabled is\n *   default\n * @param {number | false} cleanupInterval The interval in milliseconds to run a\n *   setInterval job of cleaning old entries. If false, the job will not be created.\n *   Disabled is default\n * @param {number | false} maxEntries The maximum number of entries to keep in the\n *   storage. Its hard to determine the size of the entries, so a smart FIFO order is used\n *   to determine eviction. If false, no check will be done and you may grow up memory\n *   usage. Disabled is default\n */\nexport function buildMemoryStorage(cloneData = false, cleanupInterval = false, maxEntries = false) {\n    const storage = buildStorage({\n        set: (key, value) => {\n            if (maxEntries) {\n                let keys = Object.keys(storage.data);\n                // Tries to cleanup first\n                if (keys.length >= maxEntries) {\n                    storage.cleanup();\n                    // Recalculates the keys\n                    keys = Object.keys(storage.data);\n                    // Keeps deleting until there's space\n                    while (keys.length >= maxEntries) {\n                        // There's always at least one key here, otherwise it would not be\n                        // in the loop.\n                        delete storage.data[keys.shift()];\n                    }\n                }\n            }\n            storage.data[key] =\n                // Clone the value before storing to prevent future mutations\n                // from affecting cached data.\n                cloneData === 'double'\n                    ? /* c8 ignore next 3 */\n                        typeof structuredClone === 'function'\n                            ? structuredClone(value)\n                            : JSON.parse(JSON.stringify(value))\n                    : value;\n        },\n        remove: (key) => {\n            delete storage.data[key];\n        },\n        find: (key) => {\n            const value = storage.data[key];\n            /* c8 ignore next 7 */\n            if (cloneData && value !== undefined) {\n                if (typeof structuredClone === 'function') {\n                    return structuredClone(value);\n                }\n                return JSON.parse(JSON.stringify(value));\n            }\n            return value;\n        }\n    });\n    storage.data = Object.create(null);\n    // When this program gets running for more than the specified interval, there's a good\n    // chance of it being a long-running process or at least have a lot of entries. Therefore,\n    // \"faster\" loop is more important than code readability.\n    storage.cleanup = () => {\n        const keys = Object.keys(storage.data);\n        let i = -1;\n        let value;\n        let key;\n        // Looping forward, as older entries are more likely to be expired\n        // than newer ones.\n        while (++i < keys.length) {\n            key = keys[i];\n            value = storage.data[key];\n            if (value.state === 'empty') {\n                // this storage returns void.\n                storage.remove(key);\n                continue;\n            }\n            // If the value is expired and can't be stale, remove it\n            if (value.state === 'cached' && isExpired(value) && !canStale(value)) {\n                // this storage returns void.\n                storage.remove(key);\n            }\n        }\n    };\n    if (cleanupInterval) {\n        storage.cleaner = setInterval(storage.cleanup, cleanupInterval);\n    }\n    return storage;\n}\n","function t(t,r){return t>r?1:-1}function r(o,e){var n=5381;if(\"object\"==typeof o&&null!==o&&(o.toString===Object.prototype.toString||o.toString===Array.prototype.toString)){e||(e=new WeakSet);for(var i=Object.keys(o).sort(t),a=0;a<i.length;a++){var c=i[a],g=o[c];if(n=33*n^r(c,e),\"object\"==typeof g&&null!==g&&(o.toString===Object.prototype.toString||o.toString===Array.prototype.toString)){if(e.has(g))continue;e.add(g)}n=33*n^r(g,e)}return 33*n^r(o.constructor,e)}var p=typeof o;try{o instanceof Date?p+=o.getTime():p+=String(o)}catch(t){p+=String(Object.assign({},o))}for(var f=0;f<p.length;f++)n=33*n^p.charCodeAt(f);return n}export{r as hash,t as sortNumbers};\n//# sourceMappingURL=index.mjs.map\n","import { hash } from 'object-code';\n// Remove first and last '/' char, if present\nconst SLASHES_REGEX = /^\\/|\\/$/g;\n/**\n * Builds an generator that receives a {@link CacheRequestConfig} and returns a value\n * hashed by {@link hash}.\n *\n * The value is hashed into a signed integer when the returned value from the provided\n * generator is not a `string` or a `number`.\n *\n * You can return any type of data structure.\n *\n * @example\n *\n * ```js\n * // This generator will return a hash code.\n * // The code will only be the same if url, method and data are the same.\n * const generator = buildKeyGenerator(({ url, method, data }) => ({\n *   url,\n *   method,\n *   data\n * }));\n * ```\n */\nexport function buildKeyGenerator(generator) {\n    return (request) => {\n        if (request.id) {\n            return request.id;\n        }\n        const key = generator(request);\n        if (typeof key === 'string' || typeof key === 'number') {\n            return `${key}`;\n        }\n        return `${hash(key)}`;\n    };\n}\nexport const defaultKeyGenerator = buildKeyGenerator(({ baseURL, url, method, params, data }) => {\n    // Remove trailing slashes to avoid generating different keys for the \"same\" final url.\n    if (baseURL !== undefined) {\n        baseURL = baseURL.replace(SLASHES_REGEX, '');\n    }\n    else {\n        // just to have a consistent hash\n        baseURL = '';\n    }\n    if (url !== undefined) {\n        url = url.replace(SLASHES_REGEX, '');\n    }\n    else {\n        // just to have a consistent hash\n        url = '';\n    }\n    if (method !== undefined) {\n        method = method.toLowerCase();\n    }\n    else {\n        // just to have a consistent hash\n        method = 'get';\n    }\n    return {\n        url: baseURL + (baseURL && url ? '/' : '') + url,\n        params: params,\n        method: method,\n        data: data\n    };\n});\n","import { defaultHeaderInterpreter } from '../header/interpreter';\nimport { defaultRequestInterceptor } from '../interceptors/request';\nimport { defaultResponseInterceptor } from '../interceptors/response';\nimport { isStorage } from '../storage/build';\nimport { buildMemoryStorage } from '../storage/memory';\nimport { defaultKeyGenerator } from '../util/key-generator';\n/**\n * Apply the caching interceptors for a already created axios instance.\n *\n * ```ts\n * const axios = setupCache(axios, OPTIONS);\n * ```\n *\n * The `setupCache` function receives global options and all [request\n * specifics](https://axios-cache-interceptor.js.org/config/request-specifics) ones too.\n * This way, you can customize the defaults for all requests.\n *\n * @param axios The already created axios instance\n * @param config The config for the caching interceptors\n * @returns The same instance with extended typescript types.\n * @see https://axios-cache-interceptor.js.org/config\n */\nexport function setupCache(axios, options = {}) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const axiosCache = axios;\n    if (axiosCache.defaults.cache) {\n        throw new Error('setupCache() should be called only once');\n    }\n    axiosCache.storage = options.storage || buildMemoryStorage();\n    if (!isStorage(axiosCache.storage)) {\n        throw new Error('Use buildStorage() function');\n    }\n    axiosCache.waiting = options.waiting || {};\n    axiosCache.generateKey = options.generateKey || defaultKeyGenerator;\n    axiosCache.headerInterpreter = options.headerInterpreter || defaultHeaderInterpreter;\n    axiosCache.requestInterceptor =\n        options.requestInterceptor || defaultRequestInterceptor(axiosCache);\n    axiosCache.responseInterceptor =\n        options.responseInterceptor || defaultResponseInterceptor(axiosCache);\n    axiosCache.debug = options.debug || function noop() { };\n    // CacheRequestConfig values\n    axiosCache.defaults.cache = {\n        update: options.update || {},\n        ttl: (_a = options.ttl) !== null && _a !== void 0 ? _a : 1000 * 60 * 5,\n        // Although RFC 7231 also marks POST as cacheable, most users don't know that\n        // and may have problems about why their \"create X\" route not working.\n        methods: options.methods || ['get', 'head'],\n        cachePredicate: options.cachePredicate || {\n            // All cacheable status codes defined in RFC 7231\n            statusCheck: (status) => [200, 203, 300, 301, 302, 404, 405, 410, 414, 501].includes(status)\n        },\n        etag: (_b = options.etag) !== null && _b !== void 0 ? _b : true,\n        // This option is going to be ignored by servers when ETag is enabled\n        // Checks strict equality to false to avoid undefined-ish values\n        modifiedSince: (_c = options.modifiedSince) !== null && _c !== void 0 ? _c : options.etag === false,\n        interpretHeader: (_d = options.interpretHeader) !== null && _d !== void 0 ? _d : true,\n        cacheTakeover: (_e = options.cacheTakeover) !== null && _e !== void 0 ? _e : true,\n        staleIfError: (_f = options.staleIfError) !== null && _f !== void 0 ? _f : true,\n        override: (_g = options.override) !== null && _g !== void 0 ? _g : false,\n        hydrate: (_h = options.hydrate) !== null && _h !== void 0 ? _h : undefined\n    };\n    // Apply interceptors\n    axiosCache.requestInterceptor.apply();\n    axiosCache.responseInterceptor.apply();\n    return axiosCache;\n}\n","import { buildStorage, canStale, isExpired } from './build';\n/**\n * Creates a simple storage. You can persist his data by using `sessionStorage` or\n * `localStorage` with it.\n *\n * **ImplNote**: Without polyfill, this storage only works on browser environments.\n *\n * @example\n *\n * ```js\n * const fromLocalStorage = buildWebStorage(localStorage);\n * const fromSessionStorage = buildWebStorage(sessionStorage);\n *\n * const myStorage = new Storage();\n * const fromMyStorage = buildWebStorage(myStorage);\n * ```\n *\n * @param storage The type of web storage to use. localStorage or sessionStorage.\n * @param prefix The prefix to index the storage. Useful to prevent collision between\n *   multiple places using the same storage.\n */\nexport function buildWebStorage(storage, prefix = 'axios-cache-') {\n    return buildStorage({\n        find: (key) => {\n            const json = storage.getItem(prefix + key);\n            return json ? JSON.parse(json) : undefined;\n        },\n        remove: (key) => {\n            storage.removeItem(prefix + key);\n        },\n        set: (key, value) => {\n            const save = () => storage.setItem(prefix + key, JSON.stringify(value));\n            try {\n                return save();\n            }\n            catch (error) {\n                const allValues = Object.entries(storage)\n                    .filter((item) => item[0].startsWith(prefix))\n                    .map((item) => [item[0], JSON.parse(item[1])]);\n                // Remove all expired values\n                for (const value of allValues) {\n                    if (value[1].state === 'cached' && isExpired(value[1]) && !canStale(value[1])) {\n                        storage.removeItem(value[0]);\n                    }\n                }\n                // Try save again after removing expired values\n                try {\n                    return save();\n                }\n                catch (_a) {\n                    // Storage still full, try removing the oldest value until it can be saved\n                    // Descending sort by createdAt\n                    const sortedItems = allValues.sort((a, b) => (a[1].createdAt || 0) - (b[1].createdAt || 0));\n                    for (const item of sortedItems) {\n                        storage.removeItem(item[0]);\n                        try {\n                            return save();\n                        }\n                        catch (_b) {\n                            // This key didn't free all the required space\n                        }\n                    }\n                }\n                // Clear the cache for the specified key\n                storage.removeItem(prefix + key);\n            }\n        }\n    });\n}\n","export * from './cache/axios';\nexport * from './cache/cache';\nexport * from './cache/create';\nexport * from './header/headers';\nexport * from './header/interpreter';\nexport * from './header/types';\nexport * from './interceptors/build';\nexport * from './interceptors/request';\nexport * from './interceptors/response';\nexport * from './interceptors/util';\nexport * from './storage/build';\nexport * from './storage/memory';\nexport * from './storage/types';\nexport * from './storage/web-api';\nexport * from './util/cache-predicate';\nexport * from './util/key-generator';\nexport * from './util/types';\nexport * from './util/update-cache';\nif (__ACI_DEV__) {\n    console.error('You are using a development build. Make sure to use the correct build in production\\nhttps://axios-cache-interceptor.js.org/guide/getting-started\\n\\n');\n}\n"],"names":["root","factory","exports","module","define","amd","self","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","e","a","Number","Infinity","r","t","s","n","i","toLowerCase","replace","split","u","l","m","p","h","immutable","maxAge","maxStale","minFresh","mustRevalidate","mustUnderstand","noCache","noStore","noTransform","onlyIfCached","private","proxyRevalidate","public","sMaxAge","staleIfError","staleWhileRevalidate","Header","freeze","IfModifiedSince","LastModified","IfNoneMatch","CacheControl","Pragma","ETag","Expires","Age","XAxiosCacheEtag","XAxiosCacheLastModified","XAxiosCacheStaleIfError","defaultHeaderInterpreter","headers","cacheControl","String","cache","undefined","age","stale","expires","milliseconds","Date","parse","now","createValidateStatus","oldValidate","status","isMethodIn","requestMethod","methodList","some","method","updateStaleRequest","config","_a","etag","modifiedSince","etagValue","data","createdAt","toUTCString","createCacheResponse","response","previousCache","cached","statusText","assign","defaultRequestInterceptor","axios","onFulfilled","async","_b","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","id","generateKey","debug","msg","defaults","cachePredicate","ignoreUrls","url","RegExp","lastIndex","test","includes","cacheTakeover","methods","storage","overrideCache","override","ignoreAndRequest","state","waiting","Promise","resolve","reject","catch","set","previous","validateStatus","hydrate","cachedResponse","deferred","err","adapter","apply","interceptors","request","use","testCachePredicate","predicate","statusCheck","responseMatch","containsHeaders","header","entries","updateCache","cacheUpdater","cacheKey","updater","remove","newValue","defaultResponseInterceptor","rejectResponse","responseId","cacheConfig","update","keys","startsWith","staleTtl","ttl","interpretHeader","expirationTime","headerInterpreter","cacheResponse","newCache","onRejected","error","isAxiosError","staleHeader","isStorage","hasUniqueIdentifierHeader","canStale","Math","abs","isExpired","buildStorage","find","buildMemoryStorage","cloneData","cleanupInterval","maxEntries","length","cleanup","shift","structuredClone","JSON","stringify","create","cleaner","setInterval","toString","Array","WeakSet","sort","c","g","has","add","constructor","getTime","f","charCodeAt","SLASHES_REGEX","buildKeyGenerator","generator","defaultKeyGenerator","baseURL","params","setupCache","options","axiosCache","Error","requestInterceptor","responseInterceptor","buildWebStorage","prefix","json","getItem","removeItem","save","setItem","allValues","filter","item","map","sortedItems","b","console"],"sourceRoot":""}