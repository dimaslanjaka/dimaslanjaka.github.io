import*as e from"cache-parser";import*as t from"fast-defer";import*as a from"object-code";var r={d:(e,t)=>{for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},i={};r.d(i,{h4:()=>o,UN:()=>A,uu:()=>C,Kd:()=>I,ZF:()=>T,nv:()=>b,p:()=>l,E7:()=>c,NQ:()=>d,xK:()=>E,G6:()=>g,LN:()=>m,Bw:()=>y,Ad:()=>u,$k:()=>v,v8:()=>j,Jk:()=>f,tI:()=>p,iS:()=>h});const s=(e=>{var t={};return r.d(t,e),t})({parse:()=>e.parse}),o=Object.freeze({IfModifiedSince:"if-modified-since",LastModified:"last-modified",IfNoneMatch:"if-none-match",CacheControl:"cache-control",Pragma:"pragma",ETag:"etag",Expires:"expires",Age:"age",XAxiosCacheEtag:"x-axios-cache-etag",XAxiosCacheLastModified:"x-axios-cache-last-modified",XAxiosCacheStaleIfError:"x-axios-cache-stale-if-error"}),d=e=>{if(!e)return"not enough headers";const t=e[o.CacheControl];if(t){const{noCache:a,noStore:r,maxAge:i,maxStale:d,immutable:n,staleWhileRevalidate:c}=(0,s.parse)(String(t));if(a||r)return"dont cache";if(n)return{cache:31536e6};if(void 0!==i){const t=e[o.Age];return{cache:t?1e3*(i-Number(t)):1e3*i,stale:void 0!==d?1e3*d:void 0!==c?1e3*c:void 0}}}const a=e[o.Expires];if(a){const e=Date.parse(String(a))-Date.now();return e>=0?{cache:e}:"dont cache"}return"not enough headers"};const n=(e=>{var t={};return r.d(t,e),t})({deferred:()=>t.deferred});function c(e){return e?t=>e(t)||304===t:e=>e>=200&&e<300||304===e}function u(e="get",t=[]){return e=e.toLowerCase(),t.some((t=>t===e))}function h(e,t){var a;t.headers||(t.headers={});const{etag:r,modifiedSince:i}=t.cache;if(r){const i=!0===r?null===(a=e.data)||void 0===a?void 0:a.headers[o.ETag]:r;i&&(t.headers[o.IfNoneMatch]=i)}i&&(t.headers[o.IfModifiedSince]=!0===i?e.data.headers[o.LastModified]||new Date(e.createdAt).toUTCString():i.toUTCString())}function l(e,t){return 304===e.status&&t?(e.cached=!0,e.data=t.data,e.status=t.status,e.statusText=t.statusText,e.headers=Object.assign(Object.assign({},t.headers),e.headers),t):{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers}}function g(e){const t=async a=>{var r,i,s,d,l,g,f,p,m,v,w,b,y,I,C;if(a.id=e.generateKey(a),!1===a.cache)return e.debug({id:a.id,msg:"Ignoring cache because config.cache === false",data:a}),a;if(a.cache=Object.assign(Object.assign({},e.defaults.cache),a.cache),"object"==typeof a.cache.cachePredicate&&a.cache.cachePredicate.ignoreUrls&&a.url)for(const t of a.cache.cachePredicate.ignoreUrls)if(t instanceof RegExp?(t.lastIndex=0,t.test(a.url)):a.url.includes(t))return e.debug({id:a.id,msg:`Ignored because url (${a.url}) matches ignoreUrls (${a.cache.cachePredicate.ignoreUrls})`,data:{url:a.url,cachePredicate:a.cache.cachePredicate}}),a;if(a.cache.cacheTakeover&&(null!==(r=(v=a.headers)[w=o.CacheControl])&&void 0!==r||(v[w]="no-cache"),null!==(i=(b=a.headers)[y=o.Pragma])&&void 0!==i||(b[y]="no-cache"),null!==(s=(I=a.headers)[C=o.Expires])&&void 0!==s||(I[C]="0")),!u(a.method,a.cache.methods))return e.debug({id:a.id,msg:`Ignored because method (${a.method}) is not in cache.methods (${a.cache.methods})`}),a;let x=await e.storage.get(a.id,a);const S=a.cache.override;e:if("empty"===x.state||"stale"===x.state||S){if(e.waiting[a.id]&&!S&&(x=await e.storage.get(a.id,a),"empty"!==x.state)){e.debug({id:a.id,msg:"Waiting list had an deferred for this key, waiting for it to finish"});break e}return e.waiting[a.id]=(0,n.deferred)(),e.waiting[a.id].catch((()=>{})),await e.storage.set(a.id,{state:"loading",previous:S?x.data?"stale":"empty":x.state,data:x.data,createdAt:S&&!x.createdAt?Date.now():x.createdAt},a),"stale"===x.state&&(h(x,a),e.debug({id:a.id,msg:"Updated stale request"})),a.validateStatus=c(a.validateStatus),e.debug({id:a.id,msg:"Sending request, waiting for response",data:{overrideCache:S,state:x.state}}),("stale"===x.state||x.data)&&await(null===(l=(d=a.cache).hydrate)||void 0===l?void 0:l.call(d,x)),a}let A;if("loading"===x.state){const r=e.waiting[a.id];if(!r)return x.data&&await(null===(f=(g=a.cache).hydrate)||void 0===f?void 0:f.call(g,x)),a;e.debug({id:a.id,msg:"Detected concurrent request, waiting for it to finish"});try{A=await r}catch(r){return e.debug({id:a.id,msg:"Deferred rejected, requesting again",data:r}),x.data&&await(null===(m=(p=a.cache).hydrate)||void 0===m?void 0:m.call(p,x)),t(a)}}else A=x.data;return a.adapter=function(){return Promise.resolve({config:a,data:A.data,headers:A.headers,status:A.status,statusText:A.statusText,cached:!0,id:a.id})},e.debug({id:a.id,msg:"Returning cached response"}),a};return{onFulfilled:t,apply:()=>e.interceptors.request.use(t)}}async function f(e,t){var a;if("function"==typeof t)return t(e);const{statusCheck:r,responseMatch:i,containsHeaders:s}=t;if(r&&!await r(e.status)||i&&!await i(e))return!1;if(s)for(const[t,r]of Object.entries(s))if(!await r(null!==(a=e.headers[t.toLowerCase()])&&void 0!==a?a:e.headers[t]))return!1;return!0}async function p(e,t,a){if("function"==typeof a)return a(t);for(const[r,i]of Object.entries(a)){if("delete"===i){await e.remove(r,t.config);continue}const a=await e.get(r,t.config);if("loading"===a.state)continue;const s=await i(a,t);"delete"!==s?"ignore"!==s&&await e.set(r,s,t.config):await e.remove(r,t.config)}}function m(e){const t=async(t,a)=>{var r;await e.storage.remove(t,a),null===(r=e.waiting[t])||void 0===r||r.reject(),delete e.waiting[t]},a=async a=>{var r;if(!(null==a?void 0:a.config))throw e.debug({msg:"Response interceptor received an unknown response.",data:a}),a;a.id=a.config.id,null!==(r=a.cached)&&void 0!==r||(a.cached=!1);const i=a.config,s=i.cache;if(a.cached)return e.debug({id:a.id,msg:"Returned cached response"}),a;if(!s)return e.debug({id:a.id,msg:"Response with config.cache falsy",data:a}),a.cached=!1,a;if(s.update&&await p(e.storage,a,s.update),!u(i.method,s.methods))return e.debug({id:a.id,msg:`Ignored because method (${i.method}) is not in cache.methods (${s.methods})`,data:{config:i,cacheConfig:s}}),a;const d=await e.storage.get(a.id,i);if("loading"!==d.state)return e.debug({id:a.id,msg:"Response not cached and storage isn't loading",data:{cache:d,response:a}}),a;if(!d.data&&!await f(a,s.cachePredicate))return await t(a.id,i),e.debug({id:a.id,msg:"Cache predicate rejected this response"}),a;for(const e of Object.keys(a.headers))e.startsWith("x-axios-cache")&&delete a.headers[e];s.etag&&!0!==s.etag&&(a.headers[o.XAxiosCacheEtag]=s.etag),s.modifiedSince&&(a.headers[o.XAxiosCacheLastModified]=!0===s.modifiedSince?"use-cache-timestamp":s.modifiedSince.toUTCString());let n,c=s.ttl||-1;if(s.interpretHeader){const r=e.headerInterpreter(a.headers);if("dont cache"===r)return await t(a.id,i),e.debug({id:a.id,msg:"Cache header interpreted as 'dont cache'",data:{cache:d,response:a,expirationTime:r}}),a;"not enough headers"!==r&&("number"==typeof r?c=r:(c=r.cache,n=r.stale))}const h=l(a,d.data);"function"==typeof c&&(c=await c(a)),s.staleIfError&&(a.headers[o.XAxiosCacheStaleIfError]=String(c)),e.debug({id:a.id,msg:"Useful response configuration found",data:{cacheConfig:s,cacheResponse:h}});const g={state:"cached",ttl:c,staleTtl:n,createdAt:Date.now(),data:h},m=e.waiting[a.id];return m&&(m.resolve(g.data),delete e.waiting[a.id],e.debug({id:a.id,msg:"Found waiting deferred(s) and resolved them"})),await e.storage.set(a.id,g,i),e.debug({id:a.id,msg:"Response cached",data:{cache:g,response:a}}),a},r=async a=>{var r;if(!a.isAxiosError||!a.config)throw e.debug({msg:"FATAL: Received an non axios error in the rejected response interceptor, ignoring.",data:a}),a;const i=a.config,d=i.id,n=i.cache,c=a.response;if(!n||!d)throw e.debug({msg:"Web request returned an error but cache handling is not enabled",data:{error:a}}),a;if(!u(i.method,n.methods))throw e.debug({id:d,msg:`Ignored because method (${i.method}) is not in cache.methods (${n.methods})`,data:{config:i,cacheConfig:n}}),await t(d,i),a;const h=await e.storage.get(d,i);if("loading"!==h.state||"stale"!==h.previous)throw e.debug({id:d,msg:"Caught an error in the request interceptor",data:{cache:h,error:a,config:i}}),await t(d,i),a;if(n.staleIfError){const t=String(null==c?void 0:c.headers[o.CacheControl]),u=t&&(0,s.parse)(t).staleIfError,l="function"==typeof n.staleIfError?await n.staleIfError(c,h,a):!0===n.staleIfError&&u?1e3*u:n.staleIfError;if(e.debug({id:d,msg:"Found cache if stale config for rejected response",data:{error:a,config:i,staleIfError:l}}),!0===l||"number"==typeof l&&h.createdAt+l>Date.now())return null===(r=e.waiting[d])||void 0===r||r.resolve(h.data),delete e.waiting[d],await e.storage.set(d,{state:"stale",createdAt:Date.now(),data:h.data},i),e.debug({id:d,msg:"staleIfError resolved this response with cached data",data:{error:a,config:i,cache:h}}),{cached:!0,config:i,id:d,data:h.data.data,headers:h.data.headers,status:h.data.status,statusText:h.data.statusText}}throw e.debug({id:d,msg:"Received an unknown error that could not be handled",data:{error:a,config:i}}),await t(d,i),a};return{onFulfilled:a,onRejected:r,apply:()=>e.interceptors.response.use(a,r)}}const v=e=>!!e&&!!e["is-storage"];function w(e){const t=e.data.headers;return o.ETag in t||o.LastModified in t||o.XAxiosCacheEtag in t||o.XAxiosCacheLastModified in t}function b(e){return!String(e.data.headers[o.CacheControl]).includes("must-revalidate")&&(!!w(e)||"cached"===e.state&&void 0!==e.staleTtl&&Math.abs(Date.now()-(e.createdAt+e.ttl))<=e.staleTtl)}function y(e){return void 0!==e.ttl&&e.createdAt+e.ttl<=Date.now()}function I({set:e,find:t,remove:a}){return{"is-storage":1,set:e,remove:a,get:async(r,i)=>{let s=await t(r,i);if(!s)return{state:"empty"};if("empty"===s.state||"loading"===s.state)return s;if("cached"===s.state){if(!y(s))return s;if(!b(s))return await a(r,i),{state:"empty"};s={state:"stale",createdAt:s.createdAt,data:s.data,ttl:void 0!==s.staleTtl?s.staleTtl+s.ttl:void 0},await e(r,s,i)}return y(s)?w(s)?s:(await a(r,i),{state:"empty"}):s}}}function C(e=!1,t=!1,a=!1){const r=I({set:(t,i)=>{if(a){let e=Object.keys(r.data);if(e.length>=a)for(r.cleanup(),e=Object.keys(r.data);e.length>=a;)delete r.data[e.shift()]}r.data[t]="double"===e?"function"==typeof structuredClone?structuredClone(i):JSON.parse(JSON.stringify(i)):i},remove:e=>{delete r.data[e]},find:t=>{const a=r.data[t];return e&&void 0!==a?"function"==typeof structuredClone?structuredClone(a):JSON.parse(JSON.stringify(a)):a}});return r.data=Object.create(null),r.cleanup=()=>{const e=Object.keys(r.data);let t,a,i=-1;for(;++i<e.length;)a=e[i],t=r.data[a],"empty"!==t.state?"cached"===t.state&&y(t)&&!b(t)&&r.remove(a):r.remove(a)},t&&(r.cleaner=setInterval(r.cleanup,t)),r}const x=(e=>{var t={};return r.d(t,e),t})({hash:()=>a.hash}),S=/^\/|\/$/g;function A(e){return t=>{if(t.id)return t.id;const a=e(t);return"string"==typeof a||"number"==typeof a?`${a}`:`${(0,x.hash)(a)}`}}const E=A((({baseURL:e,url:t,method:a,params:r,data:i})=>(e=void 0!==e?e.replace(S,""):"",t=void 0!==t?t.replace(S,""):"",{url:e+(e&&t?"/":"")+t,params:r,method:a=void 0!==a?a.toLowerCase():"get",data:i})));function j(e,t={}){var a,r,i,s,o,n,c,u;const h=e;if(h.defaults.cache)throw new Error("setupCache() should be called only once");if(h.storage=t.storage||C(),!v(h.storage))throw new Error("Use buildStorage() function");return h.waiting=t.waiting||{},h.generateKey=t.generateKey||E,h.headerInterpreter=t.headerInterpreter||d,h.requestInterceptor=t.requestInterceptor||g(h),h.responseInterceptor=t.responseInterceptor||m(h),h.debug=t.debug||function(){},h.defaults.cache={update:t.update||{},ttl:null!==(a=t.ttl)&&void 0!==a?a:3e5,methods:t.methods||["get","head"],cachePredicate:t.cachePredicate||{statusCheck:e=>[200,203,300,301,302,404,405,410,414,501].includes(e)},etag:null===(r=t.etag)||void 0===r||r,modifiedSince:null!==(i=t.modifiedSince)&&void 0!==i?i:!1===t.etag,interpretHeader:null===(s=t.interpretHeader)||void 0===s||s,cacheTakeover:null===(o=t.cacheTakeover)||void 0===o||o,staleIfError:null===(n=t.staleIfError)||void 0===n||n,override:null!==(c=t.override)&&void 0!==c&&c,hydrate:null!==(u=t.hydrate)&&void 0!==u?u:void 0},h.requestInterceptor.apply(),h.responseInterceptor.apply(),h}function T(e,t="axios-cache-"){return I({find:a=>{const r=e.getItem(t+a);return r?JSON.parse(r):void 0},remove:a=>{e.removeItem(t+a)},set:(a,r)=>{const i=()=>e.setItem(t+a,JSON.stringify(r));try{return i()}catch(r){const s=Object.entries(e).filter((e=>e[0].startsWith(t))).map((e=>[e[0],JSON.parse(e[1])]));for(const t of s)"cached"===t[1].state&&y(t[1])&&!b(t[1])&&e.removeItem(t[0]);try{return i()}catch(t){const a=s.sort(((e,t)=>(e[1].createdAt||0)-(t[1].createdAt||0)));for(const t of a){e.removeItem(t[0]);try{return i()}catch(e){}}}e.removeItem(t+a)}}})}console.error("You are using a development build. Make sure to use the correct build in production\nhttps://axios-cache-interceptor.js.org/guide/getting-started\n\n");var O=i.h4,k=i.UN,R=i.uu,N=i.Kd,M=i.ZF,P=i.nv,L=i.p,U=i.E7,$=i.NQ,q=i.xK,D=i.G6,J=i.LN,K=i.Bw,X=i.Ad,F=i.$k,H=i.v8,W=i.Jk,G=i.tI,B=i.iS;export{O as Header,k as buildKeyGenerator,R as buildMemoryStorage,N as buildStorage,M as buildWebStorage,P as canStale,L as createCacheResponse,U as createValidateStatus,$ as defaultHeaderInterpreter,q as defaultKeyGenerator,D as defaultRequestInterceptor,J as defaultResponseInterceptor,K as isExpired,X as isMethodIn,F as isStorage,H as setupCache,W as testCachePredicate,G as updateCache,B as updateStaleRequest};
//# sourceMappingURL=index.mjs.map