import*as e from"cache-parser";import*as t from"fast-defer";import*as a from"object-code";var r={d:(e,t)=>{for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},o={};r.d(o,{h4:()=>n,UN:()=>E,uu:()=>C,Kd:()=>I,ZF:()=>O,nv:()=>b,p:()=>h,E7:()=>c,NQ:()=>i,xK:()=>A,G6:()=>g,LN:()=>m,Bw:()=>y,Ad:()=>l,$k:()=>v,v8:()=>j,Jk:()=>f,tI:()=>p,iS:()=>u});const s=(e=>{var t={};return r.d(t,e),t})({parse:()=>e.parse}),n=Object.freeze({IfModifiedSince:"if-modified-since",LastModified:"last-modified",IfNoneMatch:"if-none-match",CacheControl:"cache-control",Pragma:"pragma",ETag:"etag",Expires:"expires",Age:"age",XAxiosCacheEtag:"x-axios-cache-etag",XAxiosCacheLastModified:"x-axios-cache-last-modified",XAxiosCacheStaleIfError:"x-axios-cache-stale-if-error"}),i=e=>{if(!e)return"not enough headers";const t=e[n.CacheControl];if(t){const{noCache:a,noStore:r,maxAge:o,maxStale:i,immutable:d,staleWhileRevalidate:c}=(0,s.parse)(String(t));if(a||r)return"dont cache";if(d)return{cache:31536e6};if(void 0!==o){const t=e[n.Age];return{cache:t?1e3*(o-Number(t)):1e3*o,stale:void 0!==i?1e3*i:void 0!==c?1e3*c:void 0}}}const a=e[n.Expires];if(a){const e=Date.parse(String(a))-Date.now();return e>=0?{cache:e}:"dont cache"}return"not enough headers"};const d=(e=>{var t={};return r.d(t,e),t})({deferred:()=>t.deferred});function c(e){return e?t=>e(t)||304===t:e=>e>=200&&e<300||304===e}function l(e="get",t=[]){return e=e.toLowerCase(),t.some((t=>t===e))}function u(e,t){var a;t.headers||(t.headers={});const{etag:r,modifiedSince:o}=t.cache;if(r){const o=!0===r?null===(a=e.data)||void 0===a?void 0:a.headers[n.ETag]:r;o&&(t.headers[n.IfNoneMatch]=o)}o&&(t.headers[n.IfModifiedSince]=!0===o?e.data.headers[n.LastModified]||new Date(e.createdAt).toUTCString():o.toUTCString())}function h(e,t){return 304===e.status&&t?(e.cached=!0,e.data=t.data,e.status=t.status,e.statusText=t.statusText,e.headers=Object.assign(Object.assign({},t.headers),e.headers),t):{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers}}function g(e){const t=async t=>{var a,r,o,s,i,h,g,f,p,m,v,w,b,y,I,C,S,x,E,A,j,O,T;const k=t.id=e.generateKey(t);if(!1===t.cache)return null===(a=e.debug)||void 0===a||a.call(e,{msg:"Ignoring cache because config.cache === false",data:t}),t;if(t.cache=Object.assign(Object.assign({},e.defaults.cache),t.cache),t.cache.cacheTakeover&&(null!==(r=(x=t.headers)[E=n.CacheControl])&&void 0!==r||(x[E]="no-cache"),null!==(o=(A=t.headers)[j=n.Pragma])&&void 0!==o||(A[j]="no-cache"),null!==(s=(O=t.headers)[T=n.Expires])&&void 0!==s||(O[T]="0")),!l(t.method,t.cache.methods))return null===(i=e.debug)||void 0===i||i.call(e,{msg:`Ignored because method (${t.method}) is not in cache.methods (${t.cache.methods})`}),t;let M=await e.storage.get(k,t);const R=t.cache.override;e:if("empty"===M.state||"stale"===M.state||R){if(e.waiting[k]&&!R&&(M=await e.storage.get(k,t),"empty"!==M.state)){null===(h=e.debug)||void 0===h||h.call(e,{id:k,msg:"Waiting list had an deferred for this key, waiting for it to finish"});break e}return e.waiting[k]=(0,d.deferred)(),e.waiting[k].catch((()=>{})),await e.storage.set(k,{state:"loading",previous:R?M.data?"stale":"empty":M.state,data:M.data,createdAt:R&&!M.createdAt?Date.now():M.createdAt},t),"stale"===M.state&&(u(M,t),null===(g=e.debug)||void 0===g||g.call(e,{id:k,msg:"Updated stale request"})),t.validateStatus=c(t.validateStatus),null===(f=e.debug)||void 0===f||f.call(e,{id:k,msg:"Sending request, waiting for response",data:{overrideCache:R,state:M.state}}),("stale"===M.state||M.data)&&await(null===(m=(p=t.cache).hydrate)||void 0===m?void 0:m.call(p,M)),t}let N;if("loading"===M.state){const a=e.waiting[k];if(!a)return await e.storage.remove(k,t),M.data&&await(null===(w=(v=t.cache).hydrate)||void 0===w?void 0:w.call(v,M)),t;null===(b=e.debug)||void 0===b||b.call(e,{id:k,msg:"Detected concurrent request, waiting for it to finish"});try{N=await a}catch(a){return null===(y=e.debug)||void 0===y||y.call(e,{id:k,msg:"Deferred rejected, requesting again",data:a}),M.data&&await(null===(C=(I=t.cache).hydrate)||void 0===C?void 0:C.call(I,M)),t}}else N=M.data;return t.adapter=()=>Promise.resolve({config:t,data:N.data,headers:N.headers,status:N.status,statusText:N.statusText,cached:!0,id:k}),null===(S=e.debug)||void 0===S||S.call(e,{id:k,msg:"Returning cached response"}),t};return{onFulfilled:t,apply:()=>e.interceptors.request.use(t)}}async function f(e,t){var a;if("function"==typeof t)return t(e);const{statusCheck:r,responseMatch:o,containsHeaders:s}=t;if(r&&!await r(e.status)||o&&!await o(e))return!1;if(s)for(const[t,r]of Object.entries(s))if(!await r(null!==(a=e.headers[t.toLowerCase()])&&void 0!==a?a:e.headers[t]))return!1;return!0}async function p(e,t,a){if("function"==typeof a)return a(t);for(const[r,o]of Object.entries(a)){if("delete"===o){await e.remove(r,t.config);continue}const a=await e.get(r,t.config);if("loading"===a.state)continue;const s=await o(a,t);"delete"!==s?"ignore"!==s&&await e.set(r,s,t.config):await e.remove(r,t.config)}}function m(e){const t=async(t,a)=>{var r;await e.storage.remove(t,a),null===(r=e.waiting[t])||void 0===r||r.reject(),delete e.waiting[t]},a=async a=>{var r,o,s,i,d,c,u,g,m,v,w,b,y;if(!a.config)throw null===(r=e.debug)||void 0===r||r.call(e,{msg:"Response interceptor received an unknown response.",data:a}),a;const I=a.id=null!==(o=(y=a.config).id)&&void 0!==o?o:y.id=e.generateKey(a.config);if(null!==(s=a.cached)&&void 0!==s||(a.cached=!1),a.cached)return null===(i=e.debug)||void 0===i||i.call(e,{id:I,msg:"Returned cached response"}),a;const C=a.config,S=C.cache;if(!S)return null===(d=e.debug)||void 0===d||d.call(e,{id:I,msg:"Response with config.cache falsy",data:a}),Object.assign(Object.assign({},a),{cached:!1});if(S.update&&await p(e.storage,a,S.update),!l(C.method,S.methods))return null===(c=e.debug)||void 0===c||c.call(e,{id:I,msg:`Ignored because method (${C.method}) is not in cache.methods (${S.methods})`,data:{config:C,cacheConfig:S}}),a;const x=await e.storage.get(I,C);if("loading"!==x.state)return null===(u=e.debug)||void 0===u||u.call(e,{id:I,msg:"Response not cached and storage isn't loading",data:{cache:x,response:a}}),a;if(!x.data&&!await f(a,S.cachePredicate))return await t(I,C),null===(g=e.debug)||void 0===g||g.call(e,{id:I,msg:"Cache predicate rejected this response"}),a;for(const e of Object.keys(a.headers))e.startsWith("x-axios-cache")&&delete a.headers[e];S.etag&&!0!==S.etag&&(a.headers[n.XAxiosCacheEtag]=S.etag),S.modifiedSince&&(a.headers[n.XAxiosCacheLastModified]=!0===S.modifiedSince?"use-cache-timestamp":S.modifiedSince.toUTCString());let E,A=S.ttl||-1;if(S.interpretHeader){const r=e.headerInterpreter(a.headers);if("dont cache"===r)return await t(I,C),null===(m=e.debug)||void 0===m||m.call(e,{id:I,msg:"Cache header interpreted as 'dont cache'",data:{cache:x,response:a,expirationTime:r}}),a;"not enough headers"!==r&&("number"==typeof r?A=r:(A=r.cache,E=r.stale))}const j=h(a,x.data);"function"==typeof A&&(A=await A(a)),S.staleIfError&&(a.headers[n.XAxiosCacheStaleIfError]=String(A)),null===(v=e.debug)||void 0===v||v.call(e,{id:I,msg:"Useful response configuration found",data:{cacheConfig:S,cacheResponse:j}});const O={state:"cached",ttl:A,staleTtl:E,createdAt:Date.now(),data:j},T=e.waiting[I];return T&&(T.resolve(O.data),delete e.waiting[I],null===(w=e.debug)||void 0===w||w.call(e,{id:I,msg:"Found waiting deferred(s) and resolved them"})),await e.storage.set(I,O,C),null===(b=e.debug)||void 0===b||b.call(e,{id:I,msg:"Response cached",data:{cache:O,response:a}}),a},r=async a=>{var r,o,i,d,c,u,h;const g=a.config,f=g.id,p=g.cache,m=a.response;if(!p||!f)throw null===(r=e.debug)||void 0===r||r.call(e,{msg:"Web request returned an error but cache handling is not enabled",data:{error:a}}),a;if(!l(g.method,p.methods))throw null===(o=e.debug)||void 0===o||o.call(e,{id:f,msg:`Ignored because method (${g.method}) is not in cache.methods (${p.methods})`,data:{config:g,cacheConfig:p}}),a;const v=await e.storage.get(f,g);if("loading"!==v.state||"stale"!==v.previous)throw await t(f,g),null===(i=e.debug)||void 0===i||i.call(e,{id:f,msg:"Caught an error in the request interceptor",data:{cache:v,error:a,config:g}}),a;if(p.staleIfError){const t=String(null==m?void 0:m.headers[n.CacheControl]),r=t&&(0,s.parse)(t).staleIfError,o="function"==typeof p.staleIfError?await p.staleIfError(m,v,a):!0===p.staleIfError&&r?1e3*r:p.staleIfError;if(null===(d=e.debug)||void 0===d||d.call(e,{id:f,msg:"Found cache if stale config for rejected response",data:{error:a,config:g,staleIfError:o}}),!0===o||"number"==typeof o&&v.createdAt+o>Date.now())return null===(c=e.waiting[f])||void 0===c||c.resolve(v.data),delete e.waiting[f],await e.storage.set(f,{state:"stale",createdAt:Date.now(),data:v.data},g),null===(u=e.debug)||void 0===u||u.call(e,{id:f,msg:"staleIfError resolved this response with cached data",data:{error:a,config:g,cache:v}}),{cached:!0,config:g,id:f,data:v.data.data,headers:v.data.headers,status:v.data.status,statusText:v.data.statusText}}throw null===(h=e.debug)||void 0===h||h.call(e,{id:f,msg:"Received an unknown error that could not be handled",data:{error:a,config:g}}),a};return{onFulfilled:a,onRejected:r,apply:()=>e.interceptors.response.use(a,r)}}const v=e=>!!e&&!!e["is-storage"];function w(e){const t=e.data.headers;return n.ETag in t||n.LastModified in t||n.XAxiosCacheEtag in t||n.XAxiosCacheLastModified in t}function b(e){return!String(e.data.headers[n.CacheControl]).includes("must-revalidate")&&(!!w(e)||"cached"===e.state&&void 0!==e.staleTtl&&Math.abs(Date.now()-(e.createdAt+e.ttl))<=e.staleTtl)}function y(e){return void 0!==e.ttl&&e.createdAt+e.ttl<=Date.now()}function I({set:e,find:t,remove:a}){return{"is-storage":1,set:e,remove:a,get:async(r,o)=>{let s=await t(r,o);if(!s)return{state:"empty"};if("empty"===s.state||"loading"===s.state)return s;if("cached"===s.state){if(!y(s))return s;if(!b(s))return await a(r,o),{state:"empty"};s={state:"stale",createdAt:s.createdAt,data:s.data,ttl:void 0!==s.staleTtl?s.staleTtl+s.ttl:void 0},await e(r,s,o)}return y(s)?w(s)?s:(await a(r,o),{state:"empty"}):s}}}function C(e=!1,t=!1,a=!1){const r=I({set:(e,t)=>{if(a){let e=Object.keys(r.data);if(e.length>=a)for(r.cleanup(),e=Object.keys(r.data);e.length>=a;)delete r.data[e.shift()]}r.data[e]=t},remove:e=>{delete r.data[e]},find:t=>{const a=r.data[t];return e&&void 0!==a?"function"==typeof structuredClone?structuredClone(a):JSON.parse(JSON.stringify(a)):a}});return r.data=Object.create(null),r.cleanup=()=>{const e=Object.keys(r.data);let t,a,o=-1;for(;++o<e.length;)a=e[o],t=r.data[a],"empty"!==t.state?"cached"===t.state&&y(t)&&!b(t)&&r.remove(a):r.remove(a)},t&&(r.cleaner=setInterval(r.cleanup,t)),r}const S=(e=>{var t={};return r.d(t,e),t})({hash:()=>a.hash}),x=/^\/|\/$/g;function E(e){return t=>{if(t.id)return t.id;const a=e(t);return"string"==typeof a||"number"==typeof a?`${a}`:`${(0,S.hash)(a)}`}}const A=E((({baseURL:e="",url:t="",method:a="get",params:r,data:o})=>(e&&(e=e.replace(x,"")),t&&(t=t.replace(x,"")),a&&(a=a.toLowerCase()),{url:e+(e&&t?"/":"")+t,params:r,method:a,data:o})));function j(e,t={}){var a,r,o,s,n,d;const c=e;if(c.defaults.cache)throw new Error("setupCache() should be called only once");if(c.storage=t.storage||C(),!v(c.storage))throw new Error("Use buildStorage() function");return c.waiting=t.waiting||{},c.generateKey=t.generateKey||A,c.headerInterpreter=t.headerInterpreter||i,c.requestInterceptor=t.requestInterceptor||g(c),c.responseInterceptor=t.responseInterceptor||m(c),c.debug=t.debug,c.defaults.cache={update:t.update||{},ttl:null!==(a=t.ttl)&&void 0!==a?a:3e5,methods:t.methods||["get","head"],cachePredicate:t.cachePredicate||{statusCheck:e=>[200,203,300,301,302,404,405,410,414,501].includes(e)},etag:null===(r=t.etag)||void 0===r||r,modifiedSince:null!==(o=t.modifiedSince)&&void 0!==o?o:!1===t.etag,interpretHeader:null===(s=t.interpretHeader)||void 0===s||s,cacheTakeover:null===(n=t.cacheTakeover)||void 0===n||n,staleIfError:null===(d=t.staleIfError)||void 0===d||d,override:!1,hydrate:void 0},c.requestInterceptor.apply(),c.responseInterceptor.apply(),c}function O(e,t="axios-cache-"){return I({find:a=>{const r=e.getItem(t+a);return r?JSON.parse(r):void 0},remove:a=>{e.removeItem(t+a)},set:(a,r)=>{const o=()=>e.setItem(t+a,JSON.stringify(r));try{return o()}catch(r){const s=Object.entries(e).filter((e=>e[0].startsWith(t))).map((e=>[e[0],JSON.parse(e[1])]));for(const t of s)"cached"===t[1].state&&y(t[1])&&!b(t[1])&&e.removeItem(t[0]);try{return o()}catch(t){const a=s.sort(((e,t)=>(e[1].createdAt||0)-(t[1].createdAt||0)));for(const t of a){e.removeItem(t[0]);try{return o()}catch(e){}}}e.removeItem(t+a)}}})}console.error("You are using a development build. Make sure to use the correct build in production\nhttps://axios-cache-interceptor.js.org/guide/getting-started\n\n");var T=o.h4,k=o.UN,M=o.uu,R=o.Kd,N=o.ZF,q=o.nv,L=o.p,D=o.E7,$=o.NQ,K=o.xK,P=o.G6,U=o.LN,X=o.Bw,J=o.Ad,F=o.$k,H=o.v8,W=o.Jk,G=o.tI,B=o.iS;export{T as Header,k as buildKeyGenerator,M as buildMemoryStorage,R as buildStorage,N as buildWebStorage,q as canStale,L as createCacheResponse,D as createValidateStatus,$ as defaultHeaderInterpreter,K as defaultKeyGenerator,P as defaultRequestInterceptor,U as defaultResponseInterceptor,X as isExpired,J as isMethodIn,F as isStorage,H as setupCache,W as testCachePredicate,G as updateCache,B as updateStaleRequest};
//# sourceMappingURL=index.mjs.map