// Axios Cache Interceptor v1.0.1 MIT License Copyright (c) 2021-present Arthur Fiorette & Contributors
import*as e from"cache-parser";import*as t from"fast-defer";import*as a from"object-code";var r={d:(e,t)=>{for(var a in t)r.o(t,a)&&!r.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t)},s={};r.d(s,{h4:()=>n,UN:()=>C,uu:()=>I,Kd:()=>x,ZF:()=>O,nv:()=>w,p:()=>h,E7:()=>d,NQ:()=>i,xK:()=>A,G6:()=>l,LN:()=>m,Bw:()=>y,Ad:()=>u,$k:()=>v,v8:()=>E,Jk:()=>g,tI:()=>p,iS:()=>f});const o=(e=>{var t={};return r.d(t,e),t})({parse:()=>e.parse}),n=Object.freeze({IfModifiedSince:"if-modified-since",LastModified:"last-modified",IfNoneMatch:"if-none-match",CacheControl:"cache-control",Pragma:"pragma",ETag:"etag",Expires:"expires",Age:"age",XAxiosCacheEtag:"x-axios-cache-etag",XAxiosCacheLastModified:"x-axios-cache-last-modified",XAxiosCacheStaleIfError:"x-axios-cache-stale-if-error"}),i=e=>{if(!e)return"not enough headers";const t=e[n.CacheControl];if(t){const{noCache:a,noStore:r,mustRevalidate:s,maxAge:i,immutable:c}=(0,o.parse)(String(t));if(a||r)return"dont cache";if(c)return 31536e6;if(s)return 0;if(void 0!==i){const t=e[n.Age];return t?1e3*(i-Number(t)):1e3*i}}const a=e[n.Expires];if(a){const e=Date.parse(String(a))-Date.now();return e>=0?e:"dont cache"}return"not enough headers"};const c=(e=>{var t={};return r.d(t,e),t})({deferred:()=>t.deferred});function d(e){return e?t=>e(t)||304===t:e=>e>=200&&e<300||304===e}function u(e="get",t=[]){return e=e.toLowerCase(),t.some((t=>t===e))}function f(e,t){var a;t.headers||(t.headers={});const{etag:r,modifiedSince:s}=t.cache;if(r){const s=!0===r?null===(a=e.data)||void 0===a?void 0:a.headers[n.ETag]:r;s&&(t.headers[n.IfNoneMatch]=s)}s&&(t.headers[n.IfModifiedSince]=!0===s?e.data.headers[n.LastModified]||new Date(e.createdAt).toUTCString():s.toUTCString())}function h(e,t){return 304===e.status&&t?(e.cached=!0,e.data=t.data,e.status=t.status,e.statusText=t.statusText,e.headers=Object.assign(Object.assign({},t.headers),e.headers),t):{data:e.data,status:e.status,statusText:e.statusText,headers:e.headers}}function l(e){const t=async t=>{var a,r,s,o,i,h,l,g,p;const m=t.id=e.generateKey(t);if(!1===t.cache)return t;if(t.cache=Object.assign(Object.assign({},e.defaults.cache),t.cache),t.cache.cacheTakeover&&(null!==(a=(o=t.headers)[i=n.CacheControl])&&void 0!==a||(o[i]="no-cache"),null!==(r=(h=t.headers)[l=n.Pragma])&&void 0!==r||(h[l]="no-cache"),null!==(s=(g=t.headers)[p=n.Expires])&&void 0!==s||(g[p]="0")),!u(t.method,t.cache.methods))return t;let v=await e.storage.get(m,t);const w=t.cache.override;e:if("empty"===v.state||"stale"===v.state||w){if(e.waiting[m]&&!w&&(v=await e.storage.get(m,t),"empty"!==v.state)){0;break e}return e.waiting[m]=(0,c.deferred)(),e.waiting[m].catch((()=>{})),await e.storage.set(m,{state:"loading",previous:w?v.data?"stale":"empty":v.state,data:v.data,createdAt:w&&!v.createdAt?Date.now():v.createdAt},t),"stale"===v.state&&f(v,t),t.validateStatus=d(t.validateStatus),t}let y;if("loading"===v.state){const a=e.waiting[m];if(!a)return await e.storage.remove(m,t),t;0;try{y=await a}catch(e){return t}}else y=v.data;return t.adapter=()=>Promise.resolve({config:t,data:y.data,headers:y.headers,status:y.status,statusText:y.statusText,cached:!0,id:m}),t};return{onFulfilled:t,apply:()=>e.interceptors.request.use(t)}}async function g(e,t){var a;if("function"==typeof t)return t(e);const{statusCheck:r,responseMatch:s,containsHeaders:o}=t;if(r&&!await r(e.status)||s&&!await s(e))return!1;if(o)for(const[t,r]of Object.entries(o))if(!await r(null!==(a=e.headers[t.toLowerCase()])&&void 0!==a?a:e.headers[t]))return!1;return!0}async function p(e,t,a){if("function"==typeof a)return a(t);for(const[r,s]of Object.entries(a)){if("delete"===s){await e.remove(r,t.config);continue}const a=await e.get(r,t.config);if("loading"===a.state)continue;const o=await s(a,t);"delete"!==o?"ignore"!==o&&await e.set(r,o,t.config):await e.remove(r,t.config)}}function m(e){const t=async(t,a)=>{var r;await e.storage.remove(t,a),null===(r=e.waiting[t])||void 0===r||r.reject(),delete e.waiting[t]},a=async a=>{var r,s,o;const i=a.id=null!==(r=(o=a.config).id)&&void 0!==r?r:o.id=e.generateKey(a.config);if(null!==(s=a.cached)&&void 0!==s||(a.cached=!1),a.cached)return a;const c=a.config,d=c.cache;if(!d)return Object.assign(Object.assign({},a),{cached:!1});if(d.update&&await p(e.storage,a,d.update),!u(c.method,d.methods))return a;const f=await e.storage.get(i,c);if("loading"!==f.state)return a;if(!f.data&&!await g(a,d.cachePredicate))return await t(i,c),a;for(const e of Object.keys(a.headers))e.startsWith("x-axios-cache")&&delete a.headers[e];d.etag&&!0!==d.etag&&(a.headers[n.XAxiosCacheEtag]=d.etag),d.modifiedSince&&(a.headers[n.XAxiosCacheLastModified]=!0===d.modifiedSince?"use-cache-timestamp":d.modifiedSince.toUTCString());let l=d.ttl||-1;if(d.interpretHeader){const r=e.headerInterpreter(a.headers);if("dont cache"===r)return await t(i,c),a;l="not enough headers"===r?l:r}const m=h(a,f.data);"function"==typeof l&&(l=await l(a)),d.staleIfError&&(a.headers[n.XAxiosCacheStaleIfError]=String(l));const v={state:"cached",ttl:l,createdAt:Date.now(),data:m},w=e.waiting[i];return w&&(w.resolve(v.data),delete e.waiting[i]),await e.storage.set(i,v,c),a},r=async a=>{var r;const s=a.config,o=s.id,n=s.cache;if(!n||!o)throw a;if(!u(s.method,n.methods))throw a;const i=await e.storage.get(o,s);if("loading"!==i.state||"stale"!==i.previous)throw await t(o,s),a;if(n.staleIfError){const t="function"==typeof n.staleIfError?await n.staleIfError(a.response,i,a):n.staleIfError;if(!0===t||"number"==typeof t&&i.createdAt+t>Date.now())return null===(r=e.waiting[o])||void 0===r||r.resolve(i.data),delete e.waiting[o],await e.storage.set(o,{state:"stale",createdAt:Date.now(),data:i.data},s),{cached:!0,config:s,id:o,data:i.data.data,headers:i.data.headers,status:i.data.status,statusText:i.data.statusText}}throw a};return{onFulfilled:a,onRejected:r,apply:()=>e.interceptors.response.use(a,r)}}const v=e=>!!e&&!!e["is-storage"];function w(e){const t=e.data.headers;return n.ETag in t||n.LastModified in t||n.XAxiosCacheEtag in t||n.XAxiosCacheStaleIfError in t||n.XAxiosCacheLastModified in t}function y(e){return e.createdAt+e.ttl<=Date.now()}function x({set:e,find:t,remove:a}){return{"is-storage":1,set:e,remove:a,get:async(r,s)=>{const o=await t(r,s);if(!o)return{state:"empty"};if("cached"!==o.state||!y(o))return o;if(w(o)){const t={state:"stale",createdAt:o.createdAt,data:o.data};return await e(r,t,s),t}return await a(r,s),{state:"empty"}}}}function I(e=!1){const t=x({set:(e,a)=>{t.data[e]=a},remove:e=>{delete t.data[e]},find:a=>{const r=t.data[a];return e&&void 0!==r?"function"==typeof structuredClone?structuredClone(r):JSON.parse(JSON.stringify(r)):r}});return t.data=Object.create(null),t}const S=(e=>{var t={};return r.d(t,e),t})({hash:()=>a.hash}),b=/^\/|\/$/g;function C(e){return t=>{if(t.id)return t.id;const a=e(t);return"string"==typeof a||"number"==typeof a?`${a}`:`${(0,S.hash)(a)}`}}const A=C((({baseURL:e="",url:t="",method:a="get",params:r,data:s})=>(e&&(e=e.replace(b,"")),t&&(t=t.replace(b,"")),a&&(a=a.toLowerCase()),{url:e+(e&&t?"/":"")+t,params:r,method:a,data:s})));function E(e,t={}){var a,r,s,o,n,c;const d=e;if(d.defaults.cache)throw new Error("setupCache() should be called only once");if(d.storage=t.storage||I(),!v(d.storage))throw new Error("Use buildStorage() function");return d.waiting=t.waiting||{},d.generateKey=t.generateKey||A,d.headerInterpreter=t.headerInterpreter||i,d.requestInterceptor=t.requestInterceptor||l(d),d.responseInterceptor=t.responseInterceptor||m(d),d.debug=t.debug,d.defaults.cache={update:t.update||{},ttl:null!==(a=t.ttl)&&void 0!==a?a:3e5,methods:t.methods||["get"],cachePredicate:t.cachePredicate||{statusCheck:e=>e>=200&&e<400},etag:null===(r=t.etag)||void 0===r||r,modifiedSince:null!==(s=t.modifiedSince)&&void 0!==s?s:!1===t.etag,interpretHeader:null===(o=t.interpretHeader)||void 0===o||o,cacheTakeover:null===(n=t.cacheTakeover)||void 0===n||n,staleIfError:null===(c=t.staleIfError)||void 0===c||c,override:!1},d.requestInterceptor.apply(),d.responseInterceptor.apply(),d}function O(e,t="axios-cache-"){return x({find:a=>{const r=e.getItem(t+a);return r?JSON.parse(r):void 0},remove:a=>{e.removeItem(t+a)},set:(a,r)=>{const s=()=>e.setItem(t+a,JSON.stringify(r));try{return s()}catch(r){const o=Object.entries(e).filter((e=>e[0].startsWith(t))).map((e=>[e[0],JSON.parse(e[1])]));for(const t of o)"cached"===t[1].state&&y(t[1])&&!w(t[1])&&e.removeItem(t[0]);try{return s()}catch(t){const a=o.sort(((e,t)=>(e[1].createdAt||0)-(t[1].createdAt||0)));for(const t of a){e.removeItem(t[0]);try{return s()}catch(e){}}}e.removeItem(t+a)}}})}var j=s.h4,T=s.UN,N=s.uu,M=s.Kd,L=s.ZF,k=s.nv,K=s.p,P=s.E7,X=s.NQ,D=s.xK,J=s.G6,R=s.LN,U=s.Bw,q=s.Ad,H=s.$k,$=s.v8,F=s.Jk,G=s.tI,W=s.iS;export{j as Header,T as buildKeyGenerator,N as buildMemoryStorage,M as buildStorage,L as buildWebStorage,k as canStale,K as createCacheResponse,P as createValidateStatus,X as defaultHeaderInterpreter,D as defaultKeyGenerator,J as defaultRequestInterceptor,R as defaultResponseInterceptor,U as isExpired,q as isMethodIn,H as isStorage,$ as setupCache,F as testCachePredicate,G as updateCache,W as updateStaleRequest};